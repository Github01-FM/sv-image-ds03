From 464809195d04533b1be05ebb4744d2630ba5483b Mon Sep 17 00:00:00 2001
From: xf02 <xfei@codeaurora.org>
Date: Thu, 2 Apr 2015 17:17:27 +0800
Subject: [PATCH 25/67] APBU-10242: Update omx header file from 1.1.2 to 1.2.0
 for gst-omx

Change-Id: Ie4a9ef25569c966b697ac87551990f43a4e20c40
Signed-off-by: xf02 <xfei@codeaurora.org>
---
 omx/Makefile.am                |   13 +-
 omx/gstomx.c                   |   38 +-
 omx/gstomx.h                   |    4 +-
 omx/gstomxaudiodec.c           |    2 +-
 omx/gstomxaudioenc.c           |    2 +-
 omx/gstomxaudiosink.c          |    2 +-
 omx/gstomxbufferpool.c         |    4 +-
 omx/gstomxvideo.c              |    4 +-
 omx/gstomxvideodec.c           |   14 +-
 omx/gstomxvp8dec.c             |    4 +
 omx/openmax/OMX_Audio.h        | 1773 ++++++++++++++++++----------------------
 omx/openmax/OMX_Component.h    |  366 +++------
 omx/openmax/OMX_ComponentExt.h |   61 --
 omx/openmax/OMX_ContentPipe.h  |  195 -----
 omx/openmax/OMX_Core.h         | 1290 +++++------------------------
 omx/openmax/OMX_CoreExt.h      |   73 --
 omx/openmax/OMX_IVCommon.h     |  735 ++++++-----------
 omx/openmax/OMX_Image.h        |  244 ++----
 omx/openmax/OMX_Index.h        |  123 ++-
 omx/openmax/OMX_IndexExt.h     |   93 ---
 omx/openmax/OMX_Other.h        |  291 ++-----
 omx/openmax/OMX_RoleNames.h    |  149 ++++
 omx/openmax/OMX_Types.h        |  152 +---
 omx/openmax/OMX_Video.h        |  890 +++++++-------------
 omx/openmax/OMX_VideoExt.h     |  204 -----
 25 files changed, 2086 insertions(+), 4640 deletions(-)
 delete mode 100644 omx/openmax/OMX_ComponentExt.h
 delete mode 100644 omx/openmax/OMX_ContentPipe.h
 delete mode 100644 omx/openmax/OMX_CoreExt.h
 delete mode 100644 omx/openmax/OMX_IndexExt.h
 create mode 100644 omx/openmax/OMX_RoleNames.h
 delete mode 100644 omx/openmax/OMX_VideoExt.h

diff --git a/omx/Makefile.am b/omx/Makefile.am
index b16799e..74f0f99 100644
--- a/omx/Makefile.am
+++ b/omx/Makefile.am
@@ -1,5 +1,10 @@
 plugin_LTLIBRARIES = libgstomx.la
 
+GST_CFLAGS += -fPIC -DPIC -DVDEC -DUSE_SHARING -DHAS_AVS -DHAS_H264 -DHAS_MPEG4 -DHAS_VP6 -DHAS_VP8 -DHAS_JPEG -DHAS_MPEG2 -DHAS_REAL -DHAS_VC1 \
+							-DVDEC_MSVDX_HARDWARE -DFAKE_DEVIF -DSYSBRG_BRIDGING -DUSE_FW_CTX_TRIMMING \
+							-DENABLE_NULL_DEVIF -DUSE_REAL_FW -DOMX_SHARED -D__OMX_EXPORTS -D__PORT_FWRK__  -DPORTFWRK_NO_UMISR \
+							-DUSE_FW_RELOC_INFO_PACKING -DVDEC_BRIDGING -DSECURE_USE_SYSOS -DBSPP_UM
+
 libgstomx_la_SOURCES = gstomx.c  \
       gstomxh263dec.c   \
       gstomxh264dec.c   \
@@ -17,8 +22,8 @@ libgstomx_la_SOURCES = gstomx.c  \
       gstomxsorensondec.c
 
 
-libgstomx_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS) -I openmax
-libgstomx_la_CXXFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CXXFLAGS)
+libgstomx_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS) -DHAS_GSTREAMER -I openmax
+libgstomx_la_CXXFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CXXFLAGS) -DHAS_GSTREAMER
 libgstomx_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) \
 	$(GST_BASE_LIBS) \
@@ -29,10 +34,6 @@ libgstomx_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) -lgstvideo-@GST_API_VERSION@
 
 libgstomx_la_LIBTOOLFLAGS = --tag=disable-static
 
-GST_CFLAGS += -fPIC -DPIC -DVDEC -DUSE_SHARING -DHAS_AVS -DHAS_H264 -DHAS_MPEG4 -DHAS_VP6 -DHAS_VP8 -DHAS_JPEG -DHAS_MPEG2 -DHAS_REAL -DHAS_VC1 \
-							-DVDEC_MSVDX_HARDWARE -DFAKE_DEVIF -DSYSBRG_BRIDGING -DUSE_FW_CTX_TRIMMING \
-							-DENABLE_NULL_DEVIF -DUSE_REAL_FW -DOMX_SHARED -D__OMX_EXPORTS -D__PORT_FWRK__  -DPORTFWRK_NO_UMISR \
-							-DUSE_FW_RELOC_INFO_PACKING -DVDEC_BRIDGING -DSECURE_USE_SYSOS -DBSPP_UM
 
 noinst_HEADERS = \
   gstomx.h \
diff --git a/omx/gstomx.c b/omx/gstomx.c
index 1b79b8a..1d2c301 100644
--- a/omx/gstomx.c
+++ b/omx/gstomx.c
@@ -249,7 +249,7 @@ gst_omx_component_handle_messages (GstOMXComponent * comp)
             comp->name, gst_omx_state_to_string (msg->content.state_set.state));
         comp->state = msg->content.state_set.state;
         if (comp->state == comp->pending_state)
-          comp->pending_state = OMX_StateInvalid;
+          comp->pending_state = OMX_StateReserved_0x00000000;
         break;
       }
       case GST_OMX_MESSAGE_FLUSH:{
@@ -764,7 +764,7 @@ gst_omx_component_new (GstObject * parent, const gchar * core_name,
   g_cond_init (&comp->messages_cond);
 
   g_queue_init (&comp->messages);
-  comp->pending_state = OMX_StateInvalid;
+  comp->pending_state = OMX_StateReserved_0x00000000;
   comp->last_error = OMX_ErrorNone;
 
   /* Set component role if any */
@@ -902,7 +902,7 @@ gst_omx_component_get_state (GstOMXComponent * comp, GstClockTime timeout)
   OMX_STATETYPE ret;
   gboolean signalled = TRUE;
 
-  g_return_val_if_fail (comp != NULL, OMX_StateInvalid);
+  g_return_val_if_fail (comp != NULL, OMX_StateReserved_0x00000000);
 
   GST_DEBUG_OBJECT (comp->parent, "Getting state of %s", comp->name);
 
@@ -911,14 +911,14 @@ gst_omx_component_get_state (GstOMXComponent * comp, GstClockTime timeout)
   gst_omx_component_handle_messages (comp);
 
   ret = comp->state;
-  if (comp->pending_state == OMX_StateInvalid)
+  if (comp->pending_state == OMX_StateReserved_0x00000000)
     goto done;
 /*
   if (comp->last_error != OMX_ErrorNone) {
     GST_ERROR_OBJECT (comp->parent, "Component %s in error state: %s (0x%08x)",
         comp->name, gst_omx_error_to_string (comp->last_error),
         comp->last_error);
-    ret = OMX_StateInvalid;
+    ret = OMX_StateReserved_0x00000000;
     goto done;
   }
 */
@@ -928,7 +928,7 @@ gst_omx_component_get_state (GstOMXComponent * comp, GstClockTime timeout)
   }
 
   while (signalled //&& comp->last_error == OMX_ErrorNone
-      && comp->pending_state != OMX_StateInvalid) {
+      && comp->pending_state != OMX_StateReserved_0x00000000) {
 
     signalled = gst_omx_component_wait_message (comp, timeout);
     if (signalled)
@@ -941,16 +941,16 @@ gst_omx_component_get_state (GstOMXComponent * comp, GstClockTime timeout)
           "%s got error while waiting for state change: %s (0x%08x)",
           comp->name, gst_omx_error_to_string (comp->last_error),
           comp->last_error);
-      ret = OMX_StateInvalid;
-    } else if (comp->pending_state == OMX_StateInvalid) {
+      ret = OMX_StateReserved_0x00000000;
+    } else if (comp->pending_state == OMX_StateReserved_0x00000000) {
       /* State change finished and everything's fine */
       ret = comp->state;
     } else {
-      ret = OMX_StateInvalid;
+      ret = OMX_StateReserved_0x00000000;
       g_assert_not_reached ();
     }
   } else {
-    ret = OMX_StateInvalid;
+    ret = OMX_StateReserved_0x00000000;
     GST_WARNING_OBJECT (comp->parent, "%s timeout while waiting for state "
         "change", comp->name);
   }
@@ -1947,7 +1947,7 @@ gst_omx_port_set_enabled_unlocked (GstOMXPort * port, gboolean enabled)
   if (port->enabled_pending || port->disabled_pending) {
     GST_ERROR_OBJECT (comp->parent, "%s port %d enabled/disabled pending "
         "already", comp->name, port->index);
-    err = OMX_ErrorInvalidState;
+    err = OMX_ErrorReserved_0x8000100A;
     goto done;
   }
 
@@ -2403,8 +2403,6 @@ gst_omx_error_to_string (OMX_ERRORTYPE err)
       return "Invalid component name";
     case OMX_ErrorComponentNotFound:
       return "Component not found";
-    case OMX_ErrorInvalidComponent:
-      return "Invalid component";
     case OMX_ErrorBadParameter:
       return "Bad parameter";
     case OMX_ErrorNotImplemented:
@@ -2415,7 +2413,7 @@ gst_omx_error_to_string (OMX_ERRORTYPE err)
       return "Overflow";
     case OMX_ErrorHardware:
       return "Hardware";
-    case OMX_ErrorInvalidState:
+    case OMX_ErrorReserved_0x8000100A:
       return "Invalid state";
     case OMX_ErrorStreamCorrupt:
       return "Stream corrupt";
@@ -2435,12 +2433,6 @@ gst_omx_error_to_string (OMX_ERRORTYPE err)
       return "Same state";
     case OMX_ErrorResourcesPreempted:
       return "Resources preempted";
-    case OMX_ErrorPortUnresponsiveDuringAllocation:
-      return "Port unresponsive during allocation";
-    case OMX_ErrorPortUnresponsiveDuringDeallocation:
-      return "Port unresponsive during deallocation";
-    case OMX_ErrorPortUnresponsiveDuringStop:
-      return "Port unresponsive during stop";
     case OMX_ErrorIncorrectStateTransition:
       return "Incorrect state transition";
     case OMX_ErrorIncorrectStateOperation:
@@ -2461,10 +2453,6 @@ gst_omx_error_to_string (OMX_ERRORTYPE err)
       return "Macroblock errors in frame";
     case OMX_ErrorFormatNotDetected:
       return "Format not detected";
-    case OMX_ErrorContentPipeOpenFailed:
-      return "Content pipe open failed";
-    case OMX_ErrorContentPipeCreationFailed:
-      return "Content pipe creation failed";
     case OMX_ErrorSeperateTablesUsed:
       return "Separate tables used";
     case OMX_ErrorTunnelingUnsupported:
@@ -2486,7 +2474,7 @@ const gchar *
 gst_omx_state_to_string (OMX_STATETYPE state)
 {
   switch (state) {
-    case OMX_StateInvalid:
+    case OMX_StateReserved_0x00000000:
       return "Invalid";
     case OMX_StateLoaded:
       return "Loaded";
diff --git a/omx/gstomx.h b/omx/gstomx.h
index 193541c..7ba4ef0 100644
--- a/omx/gstomx.h
+++ b/omx/gstomx.h
@@ -52,9 +52,7 @@
 #include <OMX_Broadcom.h>
 #endif
 
-#ifdef HAVE_VIDEO_EXT
-#include <OMX_VideoExt.h>
-#endif
+#include <OMX_Video.h>
 
 #ifdef GST_OMX_STRUCT_PACKING
 #pragma pack()
diff --git a/omx/gstomxaudiodec.c b/omx/gstomxaudiodec.c
index f894086..783b79e 100644
--- a/omx/gstomxaudiodec.c
+++ b/omx/gstomxaudiodec.c
@@ -174,7 +174,7 @@ gst_omx_audio_dec_shutdown (GstOMXAudioDec * self)
   GST_DEBUG_OBJECT (self, "Shutting down decoder");
 
   state = gst_omx_component_get_state (self->dec, 0);
-  if (state > OMX_StateLoaded || state == OMX_StateInvalid) {
+  if (state > OMX_StateLoaded || state == OMX_StateReserved_0x00000000) {
     if (state > OMX_StateIdle) {
       gst_omx_component_set_state (self->dec, OMX_StateIdle);
       gst_omx_component_get_state (self->dec, 5 * GST_SECOND);
diff --git a/omx/gstomxaudioenc.c b/omx/gstomxaudioenc.c
index 2557d81..3b73daa 100644
--- a/omx/gstomxaudioenc.c
+++ b/omx/gstomxaudioenc.c
@@ -163,7 +163,7 @@ gst_omx_audio_enc_shutdown (GstOMXAudioEnc * self)
   GST_DEBUG_OBJECT (self, "Shutting down encoder");
 
   state = gst_omx_component_get_state (self->enc, 0);
-  if (state > OMX_StateLoaded || state == OMX_StateInvalid) {
+  if (state > OMX_StateLoaded || state == OMX_StateReserved_0x00000000) {
     if (state > OMX_StateIdle) {
       gst_omx_component_set_state (self->enc, OMX_StateIdle);
       gst_omx_component_get_state (self->enc, 5 * GST_SECOND);
diff --git a/omx/gstomxaudiosink.c b/omx/gstomxaudiosink.c
index 1739739..da07e96 100644
--- a/omx/gstomxaudiosink.c
+++ b/omx/gstomxaudiosink.c
@@ -344,7 +344,7 @@ gst_omx_audio_sink_close (GstAudioSink * audiosink)
   GST_DEBUG_OBJECT (self, "Closing audio sink");
 
   state = gst_omx_component_get_state (self->comp, 0);
-  if (state > OMX_StateLoaded || state == OMX_StateInvalid) {
+  if (state > OMX_StateLoaded || state == OMX_StateReserved_0x00000000) {
     if (state > OMX_StateIdle) {
       gst_omx_component_set_state (self->comp, OMX_StateIdle);
       gst_omx_component_get_state (self->comp, 5 * GST_SECOND);
diff --git a/omx/gstomxbufferpool.c b/omx/gstomxbufferpool.c
index 507a084..23413a0 100644
--- a/omx/gstomxbufferpool.c
+++ b/omx/gstomxbufferpool.c
@@ -26,8 +26,8 @@
 #include "stdio.h"
 #include "stdlib.h"
 #include "gstomxbufferpool.h"
-#include "OMX_VideoExt.h" 
-#include "OMX_IndexExt.h"
+#include "OMX_Video.h" 
+#include "OMX_Index.h"
 
 GST_DEBUG_CATEGORY_STATIC (gst_omx_buffer_pool_debug_category);
 #define GST_CAT_DEFAULT gst_omx_buffer_pool_debug_category
diff --git a/omx/gstomxvideo.c b/omx/gstomxvideo.c
index cb369c5..a1f0da3 100644
--- a/omx/gstomxvideo.c
+++ b/omx/gstomxvideo.c
@@ -27,8 +27,8 @@
 #endif
 #include <stdio.h>
 #include "gstomxvideo.h"
-#include "OMX_VideoExt.h" 
-#include "OMX_IndexExt.h"
+#include "OMX_Video.h" 
+#include "OMX_Index.h"
 
 GST_DEBUG_CATEGORY (gst_omx_video_debug_category);
 #define GST_CAT_DEFAULT gst_omx_video_debug_category
diff --git a/omx/gstomxvideodec.c b/omx/gstomxvideodec.c
index 7ec1040..2036dd0 100644
--- a/omx/gstomxvideodec.c
+++ b/omx/gstomxvideodec.c
@@ -25,8 +25,8 @@
 #endif
 
 #include <gst/gst.h>
-#include "OMX_VideoExt.h" 
-#include "OMX_IndexExt.h"
+#include "OMX_Video.h"
+#include "OMX_Index.h"
 
 #if defined (USE_OMX_TARGET_RPI) && defined(__GNUC__)
 #ifndef __VCCOREVER__
@@ -55,8 +55,8 @@
 #include "gstomxbufferpool.h"
 #include "gstomxvideo.h"
 #include "gstomxvideodec.h"
-#include "OMX_VideoExt.h"
-#include "OMX_IndexExt.h"
+#include "OMX_Video.h"
+#include "OMX_Index.h"
 
 
 GST_DEBUG_CATEGORY_STATIC (gst_omx_video_dec_debug_category);
@@ -463,7 +463,7 @@ gst_omx_video_dec_shutdown (GstOMXVideoDec * self)
 
 #if defined (USE_OMX_TARGET_RPI) && defined (HAVE_GST_GL)
   state = gst_omx_component_get_state (self->egl_render, 0);
-  if (state > OMX_StateLoaded || state == OMX_StateInvalid) {
+  if (state > OMX_StateLoaded || state == OMX_StateReserved_0x00000000) {
     if (state > OMX_StateIdle) {
       gst_omx_component_set_state (self->egl_render, OMX_StateIdle);
       gst_omx_component_set_state (self->dec, OMX_StateIdle);
@@ -1460,7 +1460,7 @@ gst_omx_video_dec_reconfigure_output_port (GstOMXVideoDec * self,OMX_CONFIG_RECT
     gst_omx_port_set_enabled (self->dec_out_port, FALSE);
     gst_omx_port_wait_enabled (self->dec_out_port, 1 * GST_SECOND);
     egl_state = gst_omx_component_get_state (self->egl_render, 0);
-    if (egl_state > OMX_StateLoaded || egl_state == OMX_StateInvalid) {
+    if (egl_state > OMX_StateLoaded || egl_state == OMX_StateReserved_0x00000000) {
       if (egl_state > OMX_StateIdle) {
         gst_omx_component_set_state (self->egl_render, OMX_StateIdle);
         gst_omx_component_get_state (self->egl_render, 5 * GST_SECOND);
@@ -2497,7 +2497,7 @@ gst_omx_video_dec_set_format (GstVideoDecoder * decoder,
         OMX_STATETYPE egl_state;
 
         egl_state = gst_omx_component_get_state (self->egl_render, 0);
-        if (egl_state > OMX_StateLoaded || egl_state == OMX_StateInvalid) {
+        if (egl_state > OMX_StateLoaded || egl_state == OMX_StateReserved_0x00000000) {
 
           if (egl_state > OMX_StateIdle) {
             gst_omx_component_set_state (self->egl_render, OMX_StateIdle);
diff --git a/omx/gstomxvp8dec.c b/omx/gstomxvp8dec.c
index 4165111..333be3c 100644
--- a/omx/gstomxvp8dec.c
+++ b/omx/gstomxvp8dec.c
@@ -91,7 +91,11 @@ gst_omx_vp8_dec_set_format (GstOMXVideoDec * dec, GstOMXPort * port,
   OMX_PARAM_PORTDEFINITIONTYPE port_def;
 
   gst_omx_port_get_port_definition (port, &port_def);
+#ifdef ANDROID
+  port_def.format.video.eCompressionFormat = OMX_VIDEO_CodingVPX;
+#else
   port_def.format.video.eCompressionFormat = OMX_VIDEO_CodingVP8;
+#endif
   ret = gst_omx_port_update_port_definition (port, &port_def) == OMX_ErrorNone;
 
   return ret;
diff --git a/omx/openmax/OMX_Audio.h b/omx/openmax/OMX_Audio.h
index 04f1a99..647571e 100644
--- a/omx/openmax/OMX_Audio.h
+++ b/omx/openmax/OMX_Audio.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,7 +21,8 @@
  *
  */
 
-/** @file OMX_Audio.h - OpenMax IL version 1.1.2
+/*
+ *  OMX_Audio.h - OpenMax IL version 1.2.0
  *  The structures needed by Audio components to exchange
  *  parameters and configuration data with the componenmilts.
  */
@@ -41,1266 +42,1086 @@ extern "C" {
 
 #include <OMX_Core.h>
 
-/** @defgroup midi MIDI
- * @ingroup audio
- */
- 
-/** @defgroup effects Audio effects
- * @ingroup audio
- */
-
-/** @defgroup audio OpenMAX IL Audio Domain
- * Structures for OpenMAX IL Audio domain
- * @{
- */
-
-/** Enumeration used to define the possible audio codings.  
- *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must 
- *  be done in a vendor specific way.  Since this is for an audio 
- *  processing element this enum is relevant.  However, for another 
- *  type of component other enums would be in this area.
- */
 typedef enum OMX_AUDIO_CODINGTYPE {
-    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
-    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
-    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
-    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
-    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
-    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
-    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
-    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
-    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
-    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
-    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
-    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
-    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
-    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
-    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
-    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
-    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
-    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
-    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
-    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
-    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
-    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
-    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
-    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
-    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
-    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
-    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
-    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
+    OMX_AUDIO_CodingUnused = 0,
+    OMX_AUDIO_CodingAutoDetect,
+    OMX_AUDIO_CodingPCM,
+    OMX_AUDIO_CodingADPCM,
+    OMX_AUDIO_CodingAMR,
+    OMX_AUDIO_CodingGSMFR,
+    OMX_AUDIO_CodingGSMEFR,
+    OMX_AUDIO_CodingGSMHR,
+    OMX_AUDIO_CodingPDCFR,
+    OMX_AUDIO_CodingPDCEFR,
+    OMX_AUDIO_CodingPDCHR,
+    OMX_AUDIO_CodingTDMAFR,
+    OMX_AUDIO_CodingTDMAEFR,
+    OMX_AUDIO_CodingQCELP8,
+    OMX_AUDIO_CodingQCELP13,
+    OMX_AUDIO_CodingEVRC,
+    OMX_AUDIO_CodingSMV,
+    OMX_AUDIO_CodingG711,
+    OMX_AUDIO_CodingG723,
+    OMX_AUDIO_CodingG726,
+    OMX_AUDIO_CodingG729,
+    OMX_AUDIO_CodingAAC,
+    OMX_AUDIO_CodingMP3,
+    OMX_AUDIO_CodingSBC,
+    OMX_AUDIO_CodingVORBIS,
+    OMX_AUDIO_CodingWMA,
+    OMX_AUDIO_CodingRA,
+    OMX_AUDIO_CodingMIDI,
     OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_CodingMax = 0x7FFFFFFF
 } OMX_AUDIO_CODINGTYPE;
 
-
-/** The PortDefinition structure is used to define all of the parameters 
- *  necessary for the compliant component to setup an input or an output audio 
- *  path.  If additional information is needed to define the parameters of the
- *  port (such as frequency), additional structures must be sent such as the
- *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
- */
 typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
-    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
-                                               for an output device, 
-                                               otherwise this field is 0 */
-    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is 
-                                          supported by the OMX component */
-    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this 
-                                          port (e.g. PCM, AMR, MP3, etc) */
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_AUDIO_CODINGTYPE eEncoding;
 } OMX_AUDIO_PORTDEFINITIONTYPE;
 
-
-/**  Port format parameter.  This structure is used to enumerate
-  *  the various data input/output format supported by the port.
-  */
 typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_U32 nPortIndex;             /**< Indicates which port to set */
-    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
-    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_AUDIO_CODINGTYPE eEncoding;
 } OMX_AUDIO_PARAM_PORTFORMATTYPE;
 
-
-/** PCM mode type  */ 
 typedef enum OMX_AUDIO_PCMMODETYPE { 
-    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */ 
-    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */ 
-    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */ 
+    OMX_AUDIO_PCMModeLinear = 0,
+    OMX_AUDIO_PCMModeALaw,
+    OMX_AUDIO_PCMModeMULaw,
     OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_PCMModeMax = 0x7FFFFFFF 
 } OMX_AUDIO_PCMMODETYPE; 
 
-
 typedef enum OMX_AUDIO_CHANNELTYPE {
-    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
-    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
-    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
-    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
-    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
-    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
-    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
-    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
-    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
-    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
+    OMX_AUDIO_ChannelNone = 0x0,
+    OMX_AUDIO_ChannelLF   = 0x1,
+    OMX_AUDIO_ChannelRF   = 0x2,
+    OMX_AUDIO_ChannelCF   = 0x3,
+    OMX_AUDIO_ChannelLS   = 0x4,
+    OMX_AUDIO_ChannelRS   = 0x5,
+    OMX_AUDIO_ChannelLFE  = 0x6,
+    OMX_AUDIO_ChannelCS   = 0x7,
+    OMX_AUDIO_ChannelLR   = 0x8,
+    OMX_AUDIO_ChannelRR   = 0x9,
+    OMX_AUDIO_ChannelLCF  = 0xA,
+    OMX_AUDIO_ChannelRCF  = 0xB,
+    OMX_AUDIO_ChannelLHS  = 0xC,
+    OMX_AUDIO_ChannelRHS  = 0xD,
+    OMX_AUDIO_ChannelCT   = 0xE,
+    OMX_AUDIO_ChannelFLT  = 0xF,
+    OMX_AUDIO_ChannelFCT  = 0x10,
+    OMX_AUDIO_ChannelFRT  = 0x11,
+    OMX_AUDIO_ChannelBLT  = 0x12,
+    OMX_AUDIO_ChannelBCT  = 0x13,
+    OMX_AUDIO_ChannelBRT  = 0x14,
+    OMX_AUDIO_ChannelUnknown           = 0x6EFFFFFF,
     OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_ChannelMax  = 0x7FFFFFFF 
 } OMX_AUDIO_CHANNELTYPE;
 
-#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
-#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
+#define OMX_AUDIO_MAXCHANNELS   36
+#define OMX_MIN_PCMPAYLOAD_MSEC 5
 
-/** PCM format description */ 
 typedef struct OMX_AUDIO_PARAM_PCMMODETYPE { 
-    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
-    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */ 
-    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */ 
-    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */ 
-    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for 
-                                           non-interleaved data (e.g. block data) */ 
-    OMX_U32 nBitPerSample;            /**< Bit per sample */ 
-    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for 
-                                           variable or unknown sampling rate. */ 
-    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */ 
-    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
-
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_NUMERICALDATATYPE eNumData;
+    OMX_ENDIANTYPE eEndian;
+    OMX_BOOL bInterleaved;
+    OMX_U32 nBitPerSample;
+    OMX_U32 nSamplingRate;
+    OMX_AUDIO_PCMMODETYPE ePCMMode;
+    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS];
 } OMX_AUDIO_PARAM_PCMMODETYPE; 
 
-
-/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
- * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC. 
- */
 typedef enum OMX_AUDIO_CHANNELMODETYPE {
-    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those 
-                                          two channels changes accordingly to each channel information */
-    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between 
-                                           2 channels for higher compression gain */
-    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half 
-                                           the bitrate of the overall bitrate */
-    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
+    OMX_AUDIO_ChannelModeStereo = 0,
+    OMX_AUDIO_ChannelModeJointStereo,
+    OMX_AUDIO_ChannelModeDual,
+    OMX_AUDIO_ChannelModeMono,
     OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
 } OMX_AUDIO_CHANNELMODETYPE;
 
-
 typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
-    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0,
+    OMX_AUDIO_MP3StreamFormatMP2Layer3,
+    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,
+    OMX_AUDIO_MP3StreamFormatUnknown           = 0x6EFFFFFF,
     OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_MP3STREAMFORMATTYPE;
 
-/** MP3 params */
 typedef struct OMX_AUDIO_PARAM_MP3TYPE {
-    OMX_U32 nSize;                 /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< port that this structure applies to */
-    OMX_U32 nChannels;             /**< Number of channels */
-    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
-                                        rate or unknown bit rates */
-    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
-                                        variable or unknown sampling rate. */
-    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
-                                        limit the audio signal. Use 0 to let encoder decide */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
-    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nBitRate;
+    OMX_U32 nSampleRate;
+    OMX_U32 nAudioBandWidth;
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;
+    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;
 } OMX_AUDIO_PARAM_MP3TYPE;
 
-
 typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
-    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
-    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
-    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
-    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
-    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
-    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
-    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
+    OMX_AUDIO_AACStreamFormatMP2ADTS = 0,
+    OMX_AUDIO_AACStreamFormatMP4ADTS,
+    OMX_AUDIO_AACStreamFormatMP4LOAS,
+    OMX_AUDIO_AACStreamFormatMP4LATM,
+    OMX_AUDIO_AACStreamFormatADIF,
+    OMX_AUDIO_AACStreamFormatMP4FF,
+    OMX_AUDIO_AACStreamFormatRAW,
+    OMX_AUDIO_AACStreamFormatUnknown           = 0x6EFFFFFF,
     OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_AACSTREAMFORMATTYPE;
 
-
-/** AAC mode type.  Note that the term profile is used with the MPEG-2
- * standard and the term object type and profile is used with MPEG-4 */
 typedef enum OMX_AUDIO_AACPROFILETYPE{
-  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
-  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
-  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
-  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
-  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
-  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
-  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
-  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
-  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
-  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
-  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
+    OMX_AUDIO_AACObjectNull = 0,
+    OMX_AUDIO_AACObjectMain = 1,
+    OMX_AUDIO_AACObjectLC,
+    OMX_AUDIO_AACObjectSSR,
+    OMX_AUDIO_AACObjectLTP,
+    OMX_AUDIO_AACObjectHE,
+    OMX_AUDIO_AACObjectScalable,
+    OMX_AUDIO_AACObjectERLC = 17,
+    OMX_AUDIO_AACObjectLD = 23,
+    OMX_AUDIO_AACObjectHE_PS = 29,
+    OMX_AUDIO_AACObjectUnknown           = 0x6EFFFFFF,
+    OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
 } OMX_AUDIO_AACPROFILETYPE;
 
+#define OMX_AUDIO_AACToolNone 0x00000000
+#define OMX_AUDIO_AACToolMS   0x00000001
+#define OMX_AUDIO_AACToolIS   0x00000002
+#define OMX_AUDIO_AACToolTNS  0x00000004
+#define OMX_AUDIO_AACToolPNS  0x00000008
+#define OMX_AUDIO_AACToolLTP  0x00000010
+#define OMX_AUDIO_AACToolAll  0x7FFFFFFF
 
-/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
- * Required for encoder configuration and optional as decoder info output.
- * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
-#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
-#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
-#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
-#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
-#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
-#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
-#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
+#define OMX_AUDIO_AACERNone  0x00000000
+#define OMX_AUDIO_AACERVCB11 0x00000001
+#define OMX_AUDIO_AACERRVLC  0x00000002
+#define OMX_AUDIO_AACERHCR   0x00000004
+#define OMX_AUDIO_AACERAll   0x7FFFFFFF
 
-/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
- * Required for ER encoder configuration and optional as decoder info output */
-#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
-#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
-#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
-#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
-#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
-
-
-/** AAC params */
 typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
-    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
-    OMX_U32 nChannels;             /**< Number of channels */
-    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
-                                        variable or unknown sampling rate. */
-    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
-                                        rate or unknown bit rates */
-    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
-                                        limit the audio signal. Use 0 to let encoder decide */
-    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
-                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
-                                        Use 0 to let encoder decide */
-    OMX_U32 nAACtools;             /**< AAC tool usage */
-    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
-    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
-    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nSampleRate;
+    OMX_U32 nBitRate;
+    OMX_U32 nAudioBandWidth;
+    OMX_U32 nFrameLength;
+    OMX_U32 nAACtools;
+    OMX_U32 nAACERtools;
+    OMX_AUDIO_AACPROFILETYPE eAACProfile;
+    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat;
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;
 } OMX_AUDIO_PARAM_AACPROFILETYPE;
 
-
-/** VORBIS params */
 typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nChannels;        /**< Number of channels */
-    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
-                                   rate or unknown bit rates. Encoding is set to the
-                                   bitrate closest to specified  value (in bps) */
-    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
-    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
-
-    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
-                                   variable or unknown sampling rate. */
-    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
-                                   limit the audio signal. Use 0 to let encoder decide */
-    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
-                                   In the default mode of operation, teh quality level is 3.
-                                   Normal quality range is 0 - 10. */
-    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
-                                   normal VBR encoding, but allows hard or soft bitrate
-                                   constraints to be enforced by the encoder. This mode can
-                                   be slower, and may also be lower quality. It is
-                                   primarily useful for streaming. */
-    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on 
-                                   non-stereo streams). Useful for lower-bitrate encoding. */     
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nBitRate;
+    OMX_U32 nMinBitRate;
+    OMX_U32 nMaxBitRate;
+    OMX_U32 nSampleRate;
+    OMX_U32 nAudioBandWidth;
+    OMX_S32 nQuality;
+    OMX_BOOL bManaged;
+    OMX_BOOL bDownmix;
 } OMX_AUDIO_PARAM_VORBISTYPE;
 
-
-/** WMA Version */
 typedef enum OMX_AUDIO_WMAFORMATTYPE {
-  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
-  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
-  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
-  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
-  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
+    OMX_AUDIO_WMAFormatUnused = 0,
+    OMX_AUDIO_WMAFormat7,
+    OMX_AUDIO_WMAFormat8,
+    OMX_AUDIO_WMAFormat9,
+    OMX_AUDIO_WMAFormat9_Professional,
+    OMX_AUDIO_WMAFormat9_Lossless,
+    OMX_AUDIO_WMAFormat9_Voice,
+    OMX_AUDIO_WMAFormat10_Professional,
+    OMX_AUDIO_WMAFormat10_Voice,
+    OMX_AUDIO_WMAFormatUnknown           = 0x6EFFFFFF,
+    OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_WMAFORMATTYPE;
 
-
-/** WMA Profile */
 typedef enum OMX_AUDIO_WMAPROFILETYPE {
-  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
-  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
-  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
-  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
-  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
+    OMX_AUDIO_WMAProfileUnused = 0,
+    OMX_AUDIO_WMAProfileL1,
+    OMX_AUDIO_WMAProfileL2,
+    OMX_AUDIO_WMAProfileL3,
+    OMX_AUDIO_WMAProfileM0,
+    OMX_AUDIO_WMAProfileM1,
+    OMX_AUDIO_WMAProfileM2,
+    OMX_AUDIO_WMAProfileM3,
+    OMX_AUDIO_WMAProfileN1,
+    OMX_AUDIO_WMAProfileN2,
+    OMX_AUDIO_WMAProfileN3,
+    OMX_AUDIO_WMAProfileS1,
+    OMX_AUDIO_WMAProfileS2,
+    OMX_AUDIO_WMAProfileUnknown           = 0x6EFFFFFF,
+    OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
 } OMX_AUDIO_WMAPROFILETYPE;
 
-
-/** WMA params */
 typedef struct OMX_AUDIO_PARAM_WMATYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U16 nChannels;        /**< Number of channels */
-    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
-                                   rate or unknown bit rates */
-    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
-	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
-    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
-    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
-    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
-    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U16 nChannels;
+    OMX_U32 nBitRate; 
+    OMX_AUDIO_WMAFORMATTYPE eFormat;
+    OMX_AUDIO_WMAPROFILETYPE eProfile;
+    OMX_U32 nSamplingRate;
+    OMX_U16 nBlockAlign;
+    OMX_U16 nEncodeOptions;
+    OMX_U32 nSuperBlockAlign;
+    OMX_U32 nBitsPerSample;
+    OMX_U32 nAdvancedEncodeOpt;
+    OMX_U32 nAdvancedEncodeOpt2;
 } OMX_AUDIO_PARAM_WMATYPE;
 
-/** 
- * RealAudio format
- */
 typedef enum OMX_AUDIO_RAFORMATTYPE {
-    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
-    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
-    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
-    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
-    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
-    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
-    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
-    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
+    OMX_AUDIO_RAFormatUnused = 0,
+    OMX_AUDIO_RA8,
+    OMX_AUDIO_RA9,
+    OMX_AUDIO_RA10_AAC,
+    OMX_AUDIO_RA10_CODEC,
+    OMX_AUDIO_RA10_LOSSLESS,
+    OMX_AUDIO_RA10_MULTICHANNEL,
+    OMX_AUDIO_RA10_VOICE,
+    OMX_AUDIO_RAFormatUnknown           = 0x6EFFFFFF,
     OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_RAFORMATTYPE;
 
-/** RA (Real Audio) params */ 
 typedef struct OMX_AUDIO_PARAM_RATYPE { 
-    OMX_U32 nSize;              /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< Port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels */ 
-    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */ 
-    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */ 
-    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */ 
-    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */ 
-    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */ 
-    OMX_U32 nNumRegions;        /**< is the number of regions value */ 
-    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nSamplingRate;
+    OMX_U32 nBitsPerFrame;
+    OMX_U32 nSamplePerFrame;
+    OMX_U32 nCouplingQuantBits;
+    OMX_U32 nCouplingStartRegion;
+    OMX_U32 nNumRegions;
+    OMX_AUDIO_RAFORMATTYPE eFormat;
 } OMX_AUDIO_PARAM_RATYPE; 
 
-
-/** SBC Allocation Method Type */
 typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
-  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
-  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
+  OMX_AUDIO_SBCAllocMethodLoudness,
+  OMX_AUDIO_SBCAllocMethodSNR,
   OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
 } OMX_AUDIO_SBCALLOCMETHODTYPE;
 
-
-/** SBC params */
 typedef struct OMX_AUDIO_PARAM_SBCTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_U32 nChannels;         /**< Number of channels */
-    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
-                                    rate or unknown bit rates */
-    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
-                                    variable or unknown sampling rate. */
-    OMX_U32 nBlocks;           /**< Number of blocks */
-    OMX_U32 nSubbands;         /**< Number of subbands */
-    OMX_U32 nBitPool;          /**< Bitpool value */
-    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
-    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nBitRate;
+    OMX_U32 nSampleRate;
+    OMX_U32 nBlocks;
+    OMX_U32 nSubbands;
+    OMX_U32 nBitPool;
+    OMX_BOOL bEnableBitrate;
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;
+    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;
 } OMX_AUDIO_PARAM_SBCTYPE;
 
-
-/** ADPCM stream format parameters */ 
 typedef struct OMX_AUDIO_PARAM_ADPCMTYPE { 
-    OMX_U32 nSize;              /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
-                                     necessarily the same as the number of channels 
-                                     to be rendered. */ 
-    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */ 
-    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for 
-                                    variable or unknown sampling rate. */ 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nBitsPerSample;
+    OMX_U32 nSampleRate;
+    OMX_U32 nBlockSize;
 } OMX_AUDIO_PARAM_ADPCMTYPE; 
 
-
-/** G723 rate */
 typedef enum OMX_AUDIO_G723RATE {
-    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
-    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
-    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
+    OMX_AUDIO_G723ModeUnused = 0,
+    OMX_AUDIO_G723ModeLow,
+    OMX_AUDIO_G723ModeHigh,
     OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
 } OMX_AUDIO_G723RATE;
 
-
-/** G723 - Sample rate must be 8 KHz */
 typedef struct OMX_AUDIO_PARAM_G723TYPE { 
-    OMX_U32 nSize;                /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */ 
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not 
-                                       necessarily the same as the number of channels 
-                                       to be rendered. */ 
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */ 
-    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */ 
-    OMX_BOOL bPostFilter;         /**< Enable Post Filter */ 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_BOOL bDTX;
+    OMX_AUDIO_G723RATE eBitRate;
+    OMX_BOOL bHiPassFilter;
+    OMX_BOOL bPostFilter;
 } OMX_AUDIO_PARAM_G723TYPE; 
 
-
-/** ITU G726 (ADPCM) rate */
 typedef enum OMX_AUDIO_G726MODE {
-    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
-    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
-    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
-    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
-    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
+    OMX_AUDIO_G726ModeUnused = 0,
+    OMX_AUDIO_G726Mode16,
+    OMX_AUDIO_G726Mode24,
+    OMX_AUDIO_G726Mode32,
+    OMX_AUDIO_G726Mode40,
     OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
 } OMX_AUDIO_G726MODE;
 
-
-/** G.726 stream format parameters - must be at 8KHz */ 
 typedef struct OMX_AUDIO_PARAM_G726TYPE { 
-    OMX_U32 nSize;              /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
-                                     necessarily the same as the number of channels 
-                                     to be rendered. */ 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
      OMX_AUDIO_G726MODE eG726Mode;
 } OMX_AUDIO_PARAM_G726TYPE; 
 
-
-/** G729 coder type */
 typedef enum OMX_AUDIO_G729TYPE {
-    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
-    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
-    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
-    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
+    OMX_AUDIO_G729 = 0,
+    OMX_AUDIO_G729A,
+    OMX_AUDIO_G729B,
+    OMX_AUDIO_G729AB,
     OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_G729Max = 0x7FFFFFFF
 } OMX_AUDIO_G729TYPE;
 
-
-/** G729 stream format parameters - fixed 6KHz sample rate */
 typedef struct OMX_AUDIO_PARAM_G729TYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
-                                   necessarily the same as the number of channels
-                                   to be rendered. */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_BOOL bDTX;
     OMX_AUDIO_G729TYPE eBitType;
 } OMX_AUDIO_PARAM_G729TYPE;
 
-
-/** AMR Frame format */ 
 typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE { 
-    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance 
-                                                   (Standard) Format */ 
-    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface 
-                                                   Format 1 */ 
-    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface 
-                                                   Format 2*/ 
-    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage 
-                                                   Format */ 
-    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time 
-                                                   Transport Protocol Payload Format */ 
-    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */ 
+    OMX_AUDIO_AMRFrameFormatConformance = 0,
+    OMX_AUDIO_AMRFrameFormatIF1,
+    OMX_AUDIO_AMRFrameFormatIF2,
+    OMX_AUDIO_AMRFrameFormatFSF,
+    OMX_AUDIO_AMRFrameFormatRTPPayloadFull,
+    OMX_AUDIO_AMRFrameFormatITU,
+    OMX_AUDIO_AMRFrameFormatRTPPayloadConstrained,
+    OMX_AUDIO_AMRFrameFormatWBPlusTIF,
+    OMX_AUDIO_AMRFrameFormatWBPlusFSF,
+    OMX_AUDIO_AMRFrameFormatWBPlusRTPPayloadBasic,
+    OMX_AUDIO_AMRFrameFormatWBPlusRTPPayloadInterleaved,
     OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF 
 } OMX_AUDIO_AMRFRAMEFORMATTYPE; 
 
-
-/** AMR band mode */
 typedef enum OMX_AUDIO_AMRBANDMODETYPE {
-    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
-    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
-    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
-    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */ 
-    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
-    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
-    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
-    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
-    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
-    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
-    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
-    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */ 
-    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */ 
-    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
-    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
-    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
-    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
-    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */      
+    OMX_AUDIO_AMRBandModeUnused = 0,
+    OMX_AUDIO_AMRBandModeNB0,
+    OMX_AUDIO_AMRBandModeNB1,
+    OMX_AUDIO_AMRBandModeNB2,
+    OMX_AUDIO_AMRBandModeNB3,
+    OMX_AUDIO_AMRBandModeNB4,
+    OMX_AUDIO_AMRBandModeNB5,
+    OMX_AUDIO_AMRBandModeNB6,
+    OMX_AUDIO_AMRBandModeNB7,
+    OMX_AUDIO_AMRBandModeWB0,
+    OMX_AUDIO_AMRBandModeWB1,
+    OMX_AUDIO_AMRBandModeWB2,
+    OMX_AUDIO_AMRBandModeWB3,
+    OMX_AUDIO_AMRBandModeWB4,
+    OMX_AUDIO_AMRBandModeWB5,
+    OMX_AUDIO_AMRBandModeWB6,
+    OMX_AUDIO_AMRBandModeWB7,
+    OMX_AUDIO_AMRBandModeWB8,
+    OMX_AUDIO_AMRBandModeWBP0,
+    OMX_AUDIO_AMRBandModeWBP1,
+    OMX_AUDIO_AMRBandModeWBP2,
+    OMX_AUDIO_AMRBandModeWBP3,
+    OMX_AUDIO_AMRBandModeWBP4,
+    OMX_AUDIO_AMRBandModeWBP5,
+    OMX_AUDIO_AMRBandModeWBP6,
+    OMX_AUDIO_AMRBandModeWBP7,
+    OMX_AUDIO_AMRBandModeWBP8,
+    OMX_AUDIO_AMRBandModeWBP9,
+    OMX_AUDIO_AMRBandModeWBP10,
+    OMX_AUDIO_AMRBandModeWBP11,
+    OMX_AUDIO_AMRBandModeWBP12,
+    OMX_AUDIO_AMRBandModeWBP13,
+    OMX_AUDIO_AMRBandModeWBP14,
+    OMX_AUDIO_AMRBandModeWBP15,
+    OMX_AUDIO_AMRBandModeWBP16,
+    OMX_AUDIO_AMRBandModeWBP17,
+    OMX_AUDIO_AMRBandModeWBP18,
+    OMX_AUDIO_AMRBandModeWBP19,
+    OMX_AUDIO_AMRBandModeWBP20,
+    OMX_AUDIO_AMRBandModeWBP21,
+    OMX_AUDIO_AMRBandModeWBP22,
+    OMX_AUDIO_AMRBandModeWBP23,
+    OMX_AUDIO_AMRBandModeWBP24,
+    OMX_AUDIO_AMRBandModeWBP25,
+    OMX_AUDIO_AMRBandModeWBP26,
+    OMX_AUDIO_AMRBandModeWBP27,
+    OMX_AUDIO_AMRBandModeWBP28,
+    OMX_AUDIO_AMRBandModeWBP29,
+    OMX_AUDIO_AMRBandModeWBP30,
+    OMX_AUDIO_AMRBandModeWBP31,
+    OMX_AUDIO_AMRBandModeWBP32,
+    OMX_AUDIO_AMRBandModeWBP33,
+    OMX_AUDIO_AMRBandModeWBP34,
+    OMX_AUDIO_AMRBandModeWBP35,
+    OMX_AUDIO_AMRBandModeWBP36,
+    OMX_AUDIO_AMRBandModeWBP37,
+    OMX_AUDIO_AMRBandModeWBP38,
+    OMX_AUDIO_AMRBandModeWBP39,
+    OMX_AUDIO_AMRBandModeWBP40,
+    OMX_AUDIO_AMRBandModeWBP41,
+    OMX_AUDIO_AMRBandModeWBP42,
+    OMX_AUDIO_AMRBandModeWBP43,
+    OMX_AUDIO_AMRBandModeWBP44,
+    OMX_AUDIO_AMRBandModeWBP45,
+    OMX_AUDIO_AMRBandModeWBP46,
+    OMX_AUDIO_AMRBandModeWBP47,
+    OMX_AUDIO_AMRBandModeAuto,
     OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
 } OMX_AUDIO_AMRBANDMODETYPE;
      
-
-/** AMR Discontinuous Transmission mode */ 
 typedef enum OMX_AUDIO_AMRDTXMODETYPE { 
-    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */ 
-    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using 
-                                             Voice Activity Detector 1 (VAD1) is enabled */ 
-    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using 
-                                             Voice Activity Detector 2 (VAD2) is enabled */       
-    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between 
-                                             Off, VAD1 or VAD2 modes */ 
-
-    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
-
+    OMX_AUDIO_AMRDTXModeOff = 0,
+    OMX_AUDIO_AMRDTXModeOnVAD1,
+    OMX_AUDIO_AMRDTXModeOnVAD2,
+    OMX_AUDIO_AMRDTXModeOnAuto,
+    OMX_AUDIO_AMRDTXasEFR,
     OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF 
 } OMX_AUDIO_AMRDTXMODETYPE; 
  
+typedef enum OMX_AUDIO_AMRISFINDEXTYPE {
+    OMX_AUDIO_AMRISFIndex0,
+    OMX_AUDIO_AMRISFIndex1,
+    OMX_AUDIO_AMRISFIndex2,
+    OMX_AUDIO_AMRISFIndex3,
+    OMX_AUDIO_AMRISFIndex4,
+    OMX_AUDIO_AMRISFIndex5,
+    OMX_AUDIO_AMRISFIndex6,
+    OMX_AUDIO_AMRISFIndex7,
+    OMX_AUDIO_AMRISFIndex8,
+    OMX_AUDIO_AMRISFIndex9,
+    OMX_AUDIO_AMRISFIndex10,
+    OMX_AUDIO_AMRISFIndex11,
+    OMX_AUDIO_AMRISFIndex12,
+    OMX_AUDIO_AMRISFIndex13,
+    OMX_AUDIO_AMRISFIndexAuto,
+    OMX_AUDIO_AMRISFIndexUknown,
+    OMX_AUDIO_AMRISFIndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRISFIndexVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRISFIndexMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRISFINDEXTYPE;
 
-/** AMR params */
 typedef struct OMX_AUDIO_PARAM_AMRTYPE {
-    OMX_U32 nSize;                          /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
-    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
-    OMX_U32 nChannels;                      /**< Number of channels */
-    OMX_U32 nBitRate;                       /**< Bit rate read only field */
-    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */ 
-    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
-    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nBitRate;
+    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode;
+    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;
+    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat;
+    OMX_AUDIO_AMRISFINDEXTYPE eAMRISFIndex;
 } OMX_AUDIO_PARAM_AMRTYPE;
 
-
-/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_GSMFRTYPE;
 
-
-/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_GSMHRTYPE;
 
-
-/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_GSMEFRTYPE;
 
-
-/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_TDMAFRTYPE;
 
-
-/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_TDMAEFRTYPE;
 
-
-/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_PDCFRTYPE;
 
-
-/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_PDCEFRTYPE;
 
-/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_BOOL bDTX;
+    OMX_BOOL bHiPassFilter;
 } OMX_AUDIO_PARAM_PDCHRTYPE;
 
-
-/** CDMA Rate types */
 typedef enum OMX_AUDIO_CDMARATETYPE {
-    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
-    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
-    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
-    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
-    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
-    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
+    OMX_AUDIO_CDMARateBlank = 0,
+    OMX_AUDIO_CDMARateFull,
+    OMX_AUDIO_CDMARateHalf,
+    OMX_AUDIO_CDMARateQuarter,
+    OMX_AUDIO_CDMARateEighth,
+    OMX_AUDIO_CDMARateErasure,
     OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
 } OMX_AUDIO_CDMARATETYPE;
 
-
-/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
-                                       rate or unknown bit rates */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_U32 nBitRate;
+    OMX_AUDIO_CDMARATETYPE eCDMARate;
+    OMX_U32 nMinBitRate;
+    OMX_U32 nMaxBitRate;
 } OMX_AUDIO_PARAM_QCELP8TYPE;
 
-
-/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_AUDIO_CDMARATETYPE eCDMARate;
+    OMX_U32 nMinBitRate;
+    OMX_U32 nMaxBitRate;
 } OMX_AUDIO_PARAM_QCELP13TYPE;
 
-
-/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
-    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
-    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
-    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
-    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_AUDIO_CDMARATETYPE eCDMARate;
+    OMX_BOOL bRATE_REDUCon;
+    OMX_U32 nMinBitRate;
+    OMX_U32 nMaxBitRate;
+    OMX_BOOL bHiPassFilter;
+    OMX_BOOL bNoiseSuppressor;
+    OMX_BOOL bPostFilter;
 } OMX_AUDIO_PARAM_EVRCTYPE;
 
-
-/** SMV ( up to 8.55kbps coder) stream format parameters */
 typedef struct OMX_AUDIO_PARAM_SMVTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
-    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
-    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
-    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_AUDIO_CDMARATETYPE eCDMARate;
+    OMX_BOOL bRATE_REDUCon;
+    OMX_U32 nMinBitRate;
+    OMX_U32 nMaxBitRate;
+    OMX_BOOL bHiPassFilter;
+    OMX_BOOL bNoiseSuppressor;
+    OMX_BOOL bPostFilter;
 } OMX_AUDIO_PARAM_SMVTYPE;
 
-
-/** MIDI Format 
- * @ingroup midi
- */
 typedef enum OMX_AUDIO_MIDIFORMATTYPE
 {
-    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
-    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
-    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
-    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
-    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
-    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
-    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
-    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
+    OMX_AUDIO_MIDIFormatUnknown = 0,
+    OMX_AUDIO_MIDIFormatSMF0,
+    OMX_AUDIO_MIDIFormatSMF1,
+    OMX_AUDIO_MIDIFormatSMF2,
+    OMX_AUDIO_MIDIFormatSPMIDI,
+    OMX_AUDIO_MIDIFormatXMF0,
+    OMX_AUDIO_MIDIFormatXMF1,
+    OMX_AUDIO_MIDIFormatMobileXMF,
     OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDIFORMATTYPE;
 
-
-/** MIDI params 
- * @ingroup midi
- */
 typedef struct OMX_AUDIO_PARAM_MIDITYPE {
-    OMX_U32 nSize;                 /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< port that this structure applies to */
-    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire 
-                                        MIDI file passed in, otherwise if 0x0, the MIDI data 
-                                        is merged and streamed (instead of passed as an 
-                                        entire MIDI file) */
-    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
-                                        voices. A value of zero indicates that the default 
-                                        polyphony of the device is used  */                                    
-    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound 
-                                        bank at initialization */
-    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */                                                                           
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nFileSize;
+    OMX_BU32 sMaxPolyphony;
+    OMX_BOOL bLoadDefaultSound;
+    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat;
 } OMX_AUDIO_PARAM_MIDITYPE;
 
-
-/** Type of the MIDI sound bank 
- * @ingroup midi
- */
 typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
-    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
-    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
-    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
-    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
-    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
+    OMX_AUDIO_MIDISoundBankUnused = 0,
+    OMX_AUDIO_MIDISoundBankDLS1,
+    OMX_AUDIO_MIDISoundBankDLS2,
+    OMX_AUDIO_MIDISoundBankMobileDLSBase,
+    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions,
     OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDISOUNDBANKTYPE;
 
-
-/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank 
- * @ingroup midi
- */
 typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
-   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
-   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
+   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,
+   OMX_AUDIO_MIDISoundBankLayoutGM,
+   OMX_AUDIO_MIDISoundBankLayoutGM2,
+   OMX_AUDIO_MIDISoundBankLayoutUser,
    OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
 
-
-/** MIDI params to load/unload user soundbank 
- * @ingroup midi
- */
 typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
-    OMX_U32 nDLSSize;         /**< Size in bytes */
-    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
-    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
-    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nDLSIndex;
+    OMX_U32 nDLSSize;
+    OMX_PTR pDLSData;
+    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;
+    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout;
 } OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
 
-
-/** Structure for Live MIDI events and MIP messages. 
- * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.) 
- * @ingroup midi
- */
 typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
-    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
-                                   array for the MIP message buffer, where the size is 
-                                   indicated by nMidiEventSize */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nMidiEventSize;
+    OMX_U8 nMidiEvents[1];
 } OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
 
-
-/** MIDI sound bank/ program pair in a given channel 
- * @ingroup midi
- */
 typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
-    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
-    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
-    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
-    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks 
-                                     by index if multiple banks are present */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannel;
+    OMX_U16 nIDProgram;
+    OMX_U16 nIDSoundBank;
+    OMX_U32 nUserSoundBankIndex;
 } OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
 
-
-/** MIDI control 
- * @ingroup midi
- */
 typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10 
-                                       format based on JAVA MMAPI (JSR-135) requirement */
-    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
-                                       number based on JSR-135 requirement */
-    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10 
-                                       fixed-point number based on JSR-135 requirement */
-    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
-                                       voices. A value of zero indicates that the default 
-                                       polyphony of the device is used  */
-    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
-    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback 
-                                       will stop automatically.  Set to zero if not used */
-    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
-    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
-    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
-    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
-    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
-    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
-
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BS32 sPitchTransposition;
+    OMX_BU32 sPlayBackRate;
+    OMX_BU32 sTempo;
+    OMX_U32 nMaxPolyphony;
+    OMX_U32 nNumRepeat;
+    OMX_U32 nStopTime;
+    OMX_U16 nChannelMuteMask;
+    OMX_U16 nChannelSoloMask;
+    OMX_U32 nTrack0031MuteMask;
+    OMX_U32 nTrack3263MuteMask;
+    OMX_U32 nTrack0031SoloMask;
+    OMX_U32 nTrack3263SoloMask;
 } OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
 
-
-/** MIDI Playback States 
- * @ingroup midi
- */
 typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
-  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to 
-  													other defined states */
-  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open. 
-                                                    The MIDI engine is currently processing 
-                                                    MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being 
-                                                    primed. The MIDI engine is currently 
-                                                    processing MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but 
-                                                    not playing. The MIDI engine is currently
-                                                    processing MIDI events. The transition to
-                                                    this state is only possible from the 
-                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
-                                                    when the 'playback head' reaches the end
-                                                    of media data or the playback stops due
-                                                    to stop time set.*/
-  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
-                                                    playing. The MIDI engine is currently
-                                                    processing MIDI events.*/
-  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
-                                                    resource constraints */
-  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
-                                                    SP-MIDI content constraints, there is
-                                                    no audible MIDI content during playback
-                                                    currently. The situation may change if
-                                                    resources are freed later.*/
+  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,
+  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,
+  OMX_AUDIO_MIDIPlayBackStateParsing,
+  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,
+  OMX_AUDIO_MIDIPlayBackStatePlaying,
+  OMX_AUDIO_MIDIPlayBackStatePlayingPartially,
+  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,
   OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
 
-
-/** MIDI status 
- * @ingroup midi
- */
 typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field. 
-                                     NOTE: May not return a meaningful value until the entire 
-                                     file is parsed and buffered.  */
-    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource 
-                                     in milliseconds. NOTE: May not return a meaningful value 
-                                     until the entire file is parsed and buffered.  */  
-    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played 
-                                     in milliseconds */
-    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful 
-                                     value until the entire file is parsed and buffered. */
-    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently 
-                                     open MIDI resource. NOTE: May not return a meaningful value 
-                                     until the entire file is parsed and buffered.  */
-    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing 
-                                     MIDI resource. NOTE: May not return a meaningful value until 
-                                     the entire file is parsed and buffered. */
-    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U16 nNumTracks;
+    OMX_U32 nDuration;
+    OMX_U32 nPosition;
+    OMX_BOOL bVibra;
+    OMX_U32 nNumMetaEvents;
+    OMX_U32 nNumActiveVoices;
+    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;
 } OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
 
-
-/** MIDI Meta Event structure one per Meta Event.
- *  MIDI Meta Events are like audio metadata, except that they are interspersed 
- *  with the MIDI content throughout the file and are not localized in the header. 
- *  As such, it is necessary to retrieve information about these Meta Events from 
- *  the engine, as it encounters these Meta Events within the MIDI content. 
- *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright, 
- *  author, default tempo, etc.) scattered throughout the file. 
- *  @ingroup midi
- */
 typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{ 
-    OMX_U32 nSize;            /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
-    OMX_U32 nIndex;           /**< Index of Meta Event */ 
-    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */ 
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
-    OMX_U32 nTrack;           /**< track number for the meta event */
-    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_U8 nMetaEventType;
+    OMX_U32 nMetaEventSize;
+    OMX_U32 nTrack;
+    OMX_U32 nPosition;
 } OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE; 
 
-
-/** MIDI Meta Event Data structure - one per Meta Event. 
- * @ingroup midi
- */ 
 typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{ 
-    OMX_U32 nSize;            /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
-    OMX_U32 nIndex;           /**< Index of Meta Event */ 
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
-    OMX_U8 nData[1];          /**< array of one or more bytes of meta data 
-                                   as indicated by the nMetaEventSize field */ 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_U32 nMetaEventSize;
+    OMX_U8 nData[1];
 } OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE; 
 
-
-/** Audio Volume adjustment for a port */
 typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's volume.  Select the 
-                                     output port to adjust the master 
-                                     volume. */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) 
-                                     or logarithmic scale (mB) */
-    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
-                                     Volume logarithmic setting for this port.  The values
-                                     for volume are in mB (millibels = 1/100 dB) relative
-                                     to a gain of 1 (e.g. the output is the same as the 
-                                     input level).  Values are in mB from nMax 
-                                     (maximum volume) to nMin mB (typically negative).
-                                     Since the volume is "voltage"
-                                     and not a "power", it takes a setting of
-                                     -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the 
-                                     volume to the requested value, it must
-                                     set the volume to the closest value BELOW
-                                     the requested value.  When getting the
-                                     volume setting, the current actual volume
-                                     must be returned. */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bLinear;
+    OMX_BS32 sVolume;
 } OMX_AUDIO_CONFIG_VOLUMETYPE;
 
-
-/** Audio Volume adjustment for a channel */
 typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's volume.  Select the 
-                                     output port to adjust the master 
-                                     volume. */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
-                                     using OMX_ALL to apply volume settings
-                                     to all channels */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or 
-                                     logarithmic scale (mB) */
-    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
-                                     Volume logarithmic setting for this port.  
-                                     The values for volume are in mB 
-                                     (millibels = 1/100 dB) relative to a gain
-                                     of 1 (e.g. the output is the same as the 
-                                     input level).  Values are in mB from nMax 
-                                     (maximum volume) to nMin mB (typically negative).  
-                                     Since the volume is "voltage"
-                                     and not a "power", it takes a setting of
-                                     -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the 
-                                     volume to the requested value, it must
-                                     set the volume to the closest value BELOW
-                                     the requested value.  When getting the
-                                     volume setting, the current actual volume
-                                     must be returned. */
-    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
-                                     FALSE otherwise */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannel;
+    OMX_BOOL bLinear;
+    OMX_BS32 sVolume;
+    OMX_BOOL bIsMIDI;
 } OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
 
-
-/** Audio balance setting */
 typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's balance.  Select the 
-                                     output port to adjust the master 
-                                     balance. */
-    OMX_S32 nBalance;           /**< balance setting for this port 
-                                     (-100 to 100, where -100 indicates
-                                     all left, and no right */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nBalance;
 } OMX_AUDIO_CONFIG_BALANCETYPE;
 
-
-/** Audio Port mute */
 typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's mute.  Select the 
-                                     output port to adjust the master 
-                                     mute. */
-    OMX_BOOL bMute;             /**< Mute setting for this port */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bMute;
 } OMX_AUDIO_CONFIG_MUTETYPE;
 
-
-/** Audio Channel mute */
 typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
-                                     using OMX_ALL to apply mute settings
-                                     to all channels */
-    OMX_BOOL bMute;             /**< Mute setting for this channel */
-    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
-                                     FALSE otherwise */ 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannel;
+    OMX_BOOL bMute;
+    OMX_BOOL bIsMIDI;
 } OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
 
-
-
-/** Enable / Disable for loudness control, which boosts bass and to a 
- *  smaller extent high end frequencies to compensate for hearing
- *  ability at the extreme ends of the audio spectrum
- */ 
 typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bLoudness;
 } OMX_AUDIO_CONFIG_LOUDNESSTYPE;
 
-
-/** Enable / Disable for bass, which controls low frequencies
- */ 
 typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
-    OMX_S32 nBass;             /**< bass setting for the port, as a 
-                                    continuous value from -100 to 100  
-                                    (0 means no change in bass level)*/
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_S32 nBass;
 } OMX_AUDIO_CONFIG_BASSTYPE;
 
-
-/** Enable / Disable for treble, which controls high frequencies tones
- */ 
 typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
-    OMX_S32  nTreble;          /**< treble setting for the port, as a
-                                    continuous value from -100 to 100  
-                                    (0 means no change in treble level) */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_S32  nTreble;
 } OMX_AUDIO_CONFIG_TREBLETYPE;
 
-
-/** An equalizer is typically used for two reasons: to compensate for an 
- *  sub-optimal frequency response of a system to make it sound more natural 
- *  or to create intentionally some unnatural coloring to the sound to create
- *  an effect.
- *  @ingroup effects
- */
 typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
-    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is 
-                                    N-1, where N is the number of bands, lower limit is 0 */
-    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
-                                    read only element and is used to determine 
-                                    the lower, center and upper frequency of 
-                                    this band.  */
-    OMX_BS32 sBandLevel;       /**< band level in millibels */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_BU32 sBandIndex;
+    OMX_BU32 sCenterFreq;
+    OMX_BS32 sBandLevel;
 } OMX_AUDIO_CONFIG_EQUALIZERTYPE;
 
-
-/** Stereo widening mode type 
- * @ingroup effects
- */ 
 typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
-    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
-    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
+    OMX_AUDIO_StereoWideningHeadphones,
+    OMX_AUDIO_StereoWideningLoudspeakers,
     OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
 } OMX_AUDIO_STEREOWIDENINGTYPE;
 
-
-/** Control for stereo widening, which is a special 2-channel
- *  case of the audio virtualizer effect. For example, for 5.1-channel 
- *  output, it translates to virtual surround sound. 
- * @ingroup effects
- */ 
 typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
-    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
-    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
-                                    as a continuous value from 0 to 100  */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType;
+    OMX_U32  nStereoWidening;
 } OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
 
-
-/** The chorus effect (or ``choralizer'') is any signal processor which makes
- *  one sound source (such as a voice) sound like many such sources singing 
- *  (or playing) in unison. Since performance in unison is never exact, chorus 
- *  effects simulate this by making independently modified copies of the input 
- *  signal. Modifications may include (1) delay, (2) frequency shift, and 
- *  (3) amplitude modulation.
- * @ingroup effects
- */
 typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
-    OMX_BU32 sDelay;           /**< average delay in milliseconds */
-    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
-    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of 
-                                    delay (i.e. 0 to 100) */
-    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_BU32 sDelay;
+    OMX_BU32 sModulationRate;
+    OMX_U32 nModulationDepth;
+    OMX_BU32 nFeedback;
 } OMX_AUDIO_CONFIG_CHORUSTYPE;
 
-
-/** Reverberation is part of the reflected sound that follows the early 
- *  reflections. In a typical room, this consists of a dense succession of 
- *  echoes whose energy decays exponentially. The reverberation effect structure 
- *  as defined here includes both (early) reflections as well as (late) reverberations. 
- * @ingroup effects
- */
 typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
-    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect 
-                                       (i.e. both early reflections and late 
-                                       reverberation) in millibels */
-    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
-                                       relative to the intensity at low
-                                       frequencies in millibels */
-    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
-                                       (relative to room value), in millibels */
-    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative 
-                                       to the direct path, in milliseconds */
-    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
-                                       relative to room level, in millibels */
-    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection 
-                                       to the beginning of the late reverberation 
-                                       section, in milliseconds */
-    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
-                                       frequencies, in milliseconds */
-    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative 
-                                       to low frequency decay time in percent  */
-    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
-                                       in percent (i.e. 0 - 100) */
-    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
-                                       in percent (i.e. 0 - 100) */
-    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is 
-                                       the frequency used as the reference for all 
-                                       the high-frequency settings above */
-
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_BS32 sRoomLevel;
+    OMX_BS32 sRoomHighFreqLevel;
+    OMX_BS32 sReflectionsLevel;
+    OMX_BU32 sReflectionsDelay;
+    OMX_BS32 sReverbLevel;
+    OMX_BU32 sReverbDelay;
+    OMX_BU32 sDecayTime;
+    OMX_BU32 nDecayHighFreqRatio;
+    OMX_U32 nDensity;
+    OMX_U32 nDiffusion;
+    OMX_BU32 sReferenceHighFreq;
 } OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
 
-
-/** Possible settings for the Echo Cancelation structure to use 
- * @ingroup effects
- */
 typedef enum OMX_AUDIO_ECHOCANTYPE {
-   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
-   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation - 
-                                     echo from plastics and face */
-   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for 
-                                     Hands Free operation */
-   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for 
-                                     Car Kit (longer echo) */
+   OMX_AUDIO_EchoCanOff = 0,
+   OMX_AUDIO_EchoCanNormal,
+   OMX_AUDIO_EchoCanHFree,
+   OMX_AUDIO_EchoCanCarKit,
    OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
 } OMX_AUDIO_ECHOCANTYPE;
 
-
-/** Enable / Disable for echo cancelation, which removes undesired echo's
- *  from the audio
- * @ingroup effects
- */ 
 typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_AUDIO_ECHOCANTYPE eEchoCancelation;
 } OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
 
-
-/** Enable / Disable for noise reduction, which undesired noise from
- * the audio
- * @ingroup effects
- */ 
 typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bNoiseReduction;
 } OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
 
-/** @} */
+typedef enum OMX_AUDIO_3DOUTPUTTYPE {
+    OMX_AUDIO_3DOutputHeadphones,
+    OMX_AUDIO_3DOutputLoudspeakers,
+    OMX_AUDIO_3DOutputMax = 0x7FFFFFFF
+} OMX_AUDIO_3DOUTPUTTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DOUTPUTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_AUDIO_3DOUTPUTTYPE e3DOutputType;
+} OMX_AUDIO_CONFIG_3DOUTPUTTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DLOCATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nX;
+    OMX_S32 nY;
+    OMX_S32 nZ;
+} OMX_AUDIO_CONFIG_3DLOCATIONTYPE;
+
+typedef struct OMX_AUDIO_PARAM_3DDOPPLERMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnabled;
+} OMX_AUDIO_PARAM_3DDOPPLERMODETYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DDOPPLERSETTINGSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nSoundSpeed;
+    OMX_S32 nSourceVelocity;
+    OMX_S32 nListenerVelocity;
+} OMX_AUDIO_CONFIG_3DDOPPLERSETTINGSTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DLEVELSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BS32 sDirectLevel;
+    OMX_BS32 sRoomLevel;
+} OMX_AUDIO_CONFIG_3DLEVELSTYPE;
+
+typedef enum OMX_AUDIO_ROLLOFFMODELTYPE {
+    OMX_AUDIO_RollOffExponential,
+    OMX_AUDIO_RollOffLinear,
+    OMX_AUDIO_RollOffMax = 0x7FFFFFFF
+} OMX_AUDIO_ROLLOFFMODELTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DDISTANCEATTENUATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BS32 sMinDistance;
+    OMX_BS32 sMaxDistance;
+    OMX_BS32 sRollOffFactor;
+    OMX_BS32 sRoomRollOffFactor;
+    OMX_AUDIO_ROLLOFFMODELTYPE eRollOffModel;
+    OMX_BOOL bMuteAfterMax;
+} OMX_AUDIO_CONFIG_3DDISTANCEATTENUATIONTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DDIRECTIVITYSETTINGSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BS32 sInnerAngle;
+    OMX_BS32 sOuterAngle;
+    OMX_BS32 sOuterLevel;
+} OMX_AUDIO_CONFIG_3DDIRECTIVITYSETTINGSTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DDIRECTIVITYORIENTATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nXFront;
+    OMX_S32 nYFront;
+    OMX_S32 nZFront;
+} OMX_AUDIO_CONFIG_3DDIRECTIVITYORIENTATIONTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DMACROSCOPICORIENTATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nXFront;
+    OMX_S32 nYFront;
+    OMX_S32 nZFront;
+    OMX_S32 nXAbove;
+    OMX_S32 nYAbove;
+    OMX_S32 nZAbove;
+} OMX_AUDIO_CONFIG_3DMACROSCOPICORIENTATIONTYPE;
+
+typedef struct OMX_AUDIO_CONFIG_3DMACROSCOPICSIZETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nWidth;
+    OMX_S32 nHeight;
+    OMX_S32 nDepth;
+} OMX_AUDIO_CONFIG_3DMACROSCOPICSIZETYPE;
+
+typedef struct OMX_AUDIO_PARAM_CHANNELMAPPINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nChannels;
+    OMX_AUDIO_CHANNELTYPE nChannelsMapping[OMX_AUDIO_MAXCHANNELS];
+} OMX_AUDIO_PARAM_CHANNELMAPPINGTYPE;
+
+typedef struct OMX_AUDIO_SBCBITPOOLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nNewBitPool;
+} OMX_AUDIO_SBCBITPOOLTYPE;
+
+typedef struct OMX_AUDIO_AMRMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBitRate;
+    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode;
+} OMX_AUDIO_AMRMODETYPE;
+
+typedef struct OMX_AUDIO_CONFIG_BITRATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nEncodeBitrate;
+} OMX_AUDIO_CONFIG_BITRATETYPE;
+
+typedef struct OMX_AUDIO_CONFIG_AMRISFTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_AUDIO_AMRISFINDEXTYPE  eTargetAMRISFIndex;
+} OMX_AUDIO_CONFIG_AMRISFTYPE;
+
+typedef struct OMX_AUDIO_FIXEDPOINTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nValueStartBit;
+    OMX_U32 nValueBits;
+    OMX_U32 nSignExtensionBits;
+    OMX_S32 nValuePointPosition;
+} OMX_AUDIO_FIXEDPOINTTYPE;
 
 #ifdef __cplusplus
 }
diff --git a/omx/openmax/OMX_Component.h b/omx/openmax/OMX_Component.h
index d595640..883cbc7 100644
--- a/omx/openmax/OMX_Component.h
+++ b/omx/openmax/OMX_Component.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,10 +21,12 @@
  *
  */
 
-/** OMX_Component.h - OpenMax IL version 1.1.2
- *  The OMX_Component header file contains the definitions used to define
- *  the public interface of a component.  This header file is intended to
- *  be used by both the application and the component.
+/*
+ *  OMX_Component.h - OpenMax IL version 1.2.0
+ *  The OMX_Component header file contains the definitions used
+ *  to define the public interface of a component.  This header
+ *  file is intended to be used by both the application and the
+ *  component.
  */
 
 #ifndef OMX_Component_h
@@ -35,7 +37,6 @@ extern "C" {
 #endif /* __cplusplus */
 
 
-
 /* Each OMX header must include all required header files to allow the
  *  header to compile without errors.  The includes below are required
  *  for this header file to compile successfully 
@@ -46,7 +47,6 @@ extern "C" {
 #include <OMX_Image.h>
 #include <OMX_Other.h>
 
-/** @ingroup comp */
 typedef enum OMX_PORTDOMAINTYPE { 
     OMX_PortDomainAudio, 
     OMX_PortDomainVideo, 
@@ -57,24 +57,17 @@ typedef enum OMX_PORTDOMAINTYPE {
     OMX_PortDomainMax = 0x7ffffff
 } OMX_PORTDOMAINTYPE;
 
-/** @ingroup comp */
 typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
-    OMX_U32 nSize;                 /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< Port number the structure applies to */
-    OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
-    OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
-    OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
-    OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
-    OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
-                                        OMX_CommandPortEnable/OMX_CommandPortDisable.
-                                        When disabled a port is unpopulated. A disabled port
-                                        is not populated with buffers on a transition to IDLE. */
-    OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
-                                        nBufferCountActual. A disabled port is always unpopulated. 
-                                        An enabled port is populated on a transition to OMX_StateIdle
-                                        and unpopulated on a transition to loaded. */
-    OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_DIRTYPE eDir;
+    OMX_U32 nBufferCountActual;
+    OMX_U32 nBufferCountMin;
+    OMX_U32 nBufferSize;
+    OMX_BOOL bEnabled;
+    OMX_BOOL bPopulated;
+    OMX_PORTDOMAINTYPE eDomain;
     union {
         OMX_AUDIO_PORTDEFINITIONTYPE audio;
         OMX_VIDEO_PORTDEFINITIONTYPE video;
@@ -85,40 +78,35 @@ typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
     OMX_U32 nBufferAlignment;
 } OMX_PARAM_PORTDEFINITIONTYPE;
 
-/** @ingroup comp */
 typedef struct OMX_PARAM_U32TYPE { 
-    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
-    OMX_U32 nU32;                     /**< U32 value */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nU32;
 } OMX_PARAM_U32TYPE;
 
-/** @ingroup rpm */
 typedef enum OMX_SUSPENSIONPOLICYTYPE {
-    OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
-    OMX_SuspensionEnabled,  /**< Suspension allowed */   
+    OMX_SuspensionDisabled,
+    OMX_SuspensionEnabled,
     OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_SuspensionPolicyMax = 0x7fffffff
 } OMX_SUSPENSIONPOLICYTYPE;
 
-/** @ingroup rpm */
 typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
     OMX_U32 nSize;                  
     OMX_VERSIONTYPE nVersion;        
     OMX_SUSPENSIONPOLICYTYPE ePolicy;
 } OMX_PARAM_SUSPENSIONPOLICYTYPE;
 
-/** @ingroup rpm */
 typedef enum OMX_SUSPENSIONTYPE {
-    OMX_NotSuspended, /**< component is not suspended */
-    OMX_Suspended,    /**< component is suspended */
+    OMX_NotSuspended,
+    OMX_Suspended,
     OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_SuspendMax = 0x7FFFFFFF
 } OMX_SUSPENSIONTYPE;
 
-/** @ingroup rpm */
 typedef struct OMX_PARAM_SUSPENSIONTYPE {
     OMX_U32 nSize;                  
     OMX_VERSIONTYPE nVersion;       
@@ -131,37 +119,18 @@ typedef struct OMX_CONFIG_BOOLEANTYPE {
     OMX_BOOL bEnabled;    
 } OMX_CONFIG_BOOLEANTYPE;
 
-/* Parameter specifying the content uri to use. */
-/** @ingroup cp */
-typedef struct OMX_PARAM_CONTENTURITYPE
-{
-    OMX_U32 nSize;                      /**< size of the structure in bytes, including
-                                             actual URI name */
-    OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
-    OMX_U8 contentURI[1];               /**< The URI name */
+typedef struct OMX_PARAM_CONTENTURITYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U8 contentURI[1];
 } OMX_PARAM_CONTENTURITYPE;
 
-/* Parameter specifying the pipe to use. */
-/** @ingroup cp */
-typedef struct OMX_PARAM_CONTENTPIPETYPE
-{
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
-} OMX_PARAM_CONTENTPIPETYPE;
-
-/** @ingroup rpm */
 typedef struct OMX_RESOURCECONCEALMENTTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment 
-                                            methods (like degrading algorithm quality to 
-                                            lower resource consumption or functional bypass) 
-                                            on a component as a resolution to resource conflicts. */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bResourceConcealmentForbidden;
 } OMX_RESOURCECONCEALMENTTYPE;
 
-
-/** @ingroup metadata */
 typedef enum OMX_METADATACHARSETTYPE {
     OMX_MetadataCharsetUnknown = 0,
     OMX_MetadataCharsetASCII,
@@ -202,7 +171,6 @@ typedef enum OMX_METADATACHARSETTYPE {
     OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
 } OMX_METADATACHARSETTYPE;
 
-/** @ingroup metadata */
 typedef enum OMX_METADATASCOPETYPE
 {
     OMX_MetadataScopeAllLevels,
@@ -214,7 +182,6 @@ typedef enum OMX_METADATASCOPETYPE
     OMX_MetadataScopeTypeMax = 0x7fffffff
 } OMX_METADATASCOPETYPE;
 
-/** @ingroup metadata */
 typedef enum OMX_METADATASEARCHMODETYPE
 {
     OMX_MetadataSearchValueSizeByIndex,
@@ -224,7 +191,7 @@ typedef enum OMX_METADATASEARCHMODETYPE
     OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_MetadataSearchTypeMax = 0x7fffffff
 } OMX_METADATASEARCHMODETYPE;
-/** @ingroup metadata */
+
 typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
 {
     OMX_U32 nSize;
@@ -234,7 +201,6 @@ typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
     OMX_U32 nMetadataItemCount;
 } OMX_CONFIG_METADATAITEMCOUNTTYPE;
 
-/** @ingroup metadata */
 typedef struct OMX_CONFIG_METADATAITEMTYPE
 {
     OMX_U32 nSize;
@@ -247,13 +213,12 @@ typedef struct OMX_CONFIG_METADATAITEMTYPE
     OMX_U8 nKeySizeUsed;
     OMX_U8 nKey[128];
     OMX_METADATACHARSETTYPE eValueCharset;
-    OMX_STRING sLanguageCountry;
+    OMX_U8 sLanguageCountry[128];
     OMX_U32 nValueMaxSize;
     OMX_U32 nValueSizeUsed;
     OMX_U8 nValue[1];
 } OMX_CONFIG_METADATAITEMTYPE;
 
-/* @ingroup metadata */
 typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
 {
     OMX_U32 nSize;
@@ -263,7 +228,6 @@ typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
     OMX_U32 nNumNodes;
 } OMX_CONFIG_CONTAINERNODECOUNTTYPE;
 
-/** @ingroup metadata */
 typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
 {
     OMX_U32 nSize;
@@ -272,68 +236,30 @@ typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
     OMX_U32 nParentNodeID;
     OMX_U32 nNodeIndex; 
     OMX_U32 nNodeID; 
-    OMX_STRING cNodeName;
+    OMX_U8 cNodeName[128];
     OMX_BOOL bIsLeafType;
 } OMX_CONFIG_CONTAINERNODEIDTYPE;
 
-/** @ingroup metadata */
 typedef struct OMX_PARAM_METADATAFILTERTYPE 
 { 
     OMX_U32 nSize; 
     OMX_VERSIONTYPE nVersion; 
-    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and 
-                         * the three key fields below are ignored */
+    OMX_BOOL bAllKeys;
     OMX_METADATACHARSETTYPE eKeyCharset;
     OMX_U32 nKeySizeUsed; 
-    OMX_U8   nKey [128]; 
+    OMX_U8 nKey [128]; 
     OMX_U32 nLanguageCountrySizeUsed;
     OMX_U8 nLanguageCountry[128];
-    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g. 
-                         * retained for query later). If false then
-                         * key is not part of filter */
+    OMX_BOOL bEnabled;
 } OMX_PARAM_METADATAFILTERTYPE; 
 
-/** The OMX_HANDLETYPE structure defines the component handle.  The component 
- *  handle is used to access all of the component's public methods and also
- *  contains pointers to the component's private data area.  The component
- *  handle is initialized by the OMX core (with help from the component)
- *  during the process of loading the component.  After the component is
- *  successfully loaded, the application can safely access any of the
- *  component's public functions (although some may return an error because
- *  the state is inappropriate for the access).
- * 
- *  @ingroup comp
- */
 typedef struct OMX_COMPONENTTYPE
 {
-    /** The size of this structure, in bytes.  It is the responsibility
-        of the allocator of this structure to fill in this value.  Since
-        this structure is allocated by the GetHandle function, this
-        function will fill in this value. */
     OMX_U32 nSize;
-
-    /** nVersion is the version of the OMX specification that the structure 
-        is built against.  It is the responsibility of the creator of this 
-        structure to initialize this value and every user of this structure 
-        should verify that it knows how to use the exact version of 
-        this structure found herein. */
     OMX_VERSIONTYPE nVersion;
-
-    /** pComponentPrivate is a pointer to the component private data area.  
-        This member is allocated and initialized by the component when the 
-        component is first loaded.  The application should not access this 
-        data area. */
     OMX_PTR pComponentPrivate;
-
-    /** pApplicationPrivate is a pointer that is a parameter to the 
-        OMX_GetHandle method, and contains an application private value 
-        provided by the IL client.  This application private data is 
-        returned to the IL Client by OMX in all callbacks */
     OMX_PTR pApplicationPrivate;
 
-    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL 
-        specification for details on the GetComponentVersion method.
-     */
     OMX_ERRORTYPE (*GetComponentVersion)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_OUT OMX_STRING pComponentName,
@@ -341,129 +267,41 @@ typedef struct OMX_COMPONENTTYPE
             OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
             OMX_OUT OMX_UUIDTYPE* pComponentUUID);
 
-    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL 
-        specification for details on the SendCommand method.
-     */
     OMX_ERRORTYPE (*SendCommand)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_COMMANDTYPE Cmd,
             OMX_IN  OMX_U32 nParam1,
             OMX_IN  OMX_PTR pCmdData);
 
-    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL 
-        specification for details on the GetParameter method.
-     */
     OMX_ERRORTYPE (*GetParameter)(
             OMX_IN  OMX_HANDLETYPE hComponent, 
             OMX_IN  OMX_INDEXTYPE nParamIndex,  
             OMX_INOUT OMX_PTR pComponentParameterStructure);
 
-
-    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL 
-        specification for details on the SetParameter method.
-     */
     OMX_ERRORTYPE (*SetParameter)(
             OMX_IN  OMX_HANDLETYPE hComponent, 
             OMX_IN  OMX_INDEXTYPE nIndex,
             OMX_IN  OMX_PTR pComponentParameterStructure);
 
-
-    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL 
-        specification for details on the GetConfig method.
-     */
     OMX_ERRORTYPE (*GetConfig)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_INDEXTYPE nIndex, 
             OMX_INOUT OMX_PTR pComponentConfigStructure);
 
-
-    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL 
-        specification for details on the SetConfig method.
-     */
     OMX_ERRORTYPE (*SetConfig)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_INDEXTYPE nIndex, 
             OMX_IN  OMX_PTR pComponentConfigStructure);
 
-
-    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL 
-        specification for details on the GetExtensionIndex method.
-     */
     OMX_ERRORTYPE (*GetExtensionIndex)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_STRING cParameterName,
             OMX_OUT OMX_INDEXTYPE* pIndexType);
 
-
-    /** refer to OMX_GetState in OMX_core.h or the OMX IL 
-        specification for details on the GetState method.
-     */
     OMX_ERRORTYPE (*GetState)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_OUT OMX_STATETYPE* pState);
 
-    
-    /** The ComponentTunnelRequest method will interact with another OMX
-        component to determine if tunneling is possible and to setup the
-        tunneling.  The return codes for this method can be used to 
-        determine if tunneling is not possible, or if tunneling is not
-        supported.  
-        
-        Base profile components (i.e. non-interop) do not support this
-        method and should return OMX_ErrorNotImplemented 
-
-        The interop profile component MUST support tunneling to another 
-        interop profile component with a compatible port parameters.  
-        A component may also support proprietary communication.
-        
-        If proprietary communication is supported the negotiation of 
-        proprietary communication is done outside of OMX in a vendor 
-        specific way. It is only required that the proper result be 
-        returned and the details of how the setup is done is left 
-        to the component implementation.  
-    
-        When this method is invoked when nPort in an output port, the
-        component will:
-        1.  Populate the pTunnelSetup structure with the output port's 
-            requirements and constraints for the tunnel.
-
-        When this method is invoked when nPort in an input port, the
-        component will:
-        1.  Query the necessary parameters from the output port to 
-            determine if the ports are compatible for tunneling
-        2.  If the ports are compatible, the component should store
-            the tunnel step provided by the output port
-        3.  Determine which port (either input or output) is the buffer
-            supplier, and call OMX_SetParameter on the output port to
-            indicate this selection.
-        
-        The component will return from this call within 5 msec.
-    
-        @param [in] hComp
-            Handle of the component to be accessed.  This is the component
-            handle returned by the call to the OMX_GetHandle method.
-        @param [in] nPort
-            nPort is used to select the port on the component to be used
-            for tunneling.
-        @param [in] hTunneledComp
-            Handle of the component to tunnel with.  This is the component 
-            handle returned by the call to the OMX_GetHandle method.  When
-            this parameter is 0x0 the component should setup the port for
-            communication with the application / IL Client.
-        @param [in] nPortOutput
-            nPortOutput is used indicate the port the component should
-            tunnel with.
-        @param [in] pTunnelSetup
-            Pointer to the tunnel setup structure.  When nPort is an output port
-            the component should populate the fields of this structure.  When
-            When nPort is an input port the component should review the setup
-            provided by the component with the output port.
-        @return OMX_ERRORTYPE
-            If the command successfully executes, the return code will be
-            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-        @ingroup tun
-    */
-
     OMX_ERRORTYPE (*ComponentTunnelRequest)(
         OMX_IN  OMX_HANDLETYPE hComp,
         OMX_IN  OMX_U32 nPort,
@@ -471,10 +309,6 @@ typedef struct OMX_COMPONENTTYPE
         OMX_IN  OMX_U32 nTunneledPort,
         OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup); 
 
-    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL 
-        specification for details on the UseBuffer method.
-        @ingroup buf
-     */
     OMX_ERRORTYPE (*UseBuffer)(
             OMX_IN OMX_HANDLETYPE hComponent,
             OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
@@ -483,10 +317,6 @@ typedef struct OMX_COMPONENTTYPE
             OMX_IN OMX_U32 nSizeBytes,
             OMX_IN OMX_U8* pBuffer);
 
-    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL 
-        specification for details on the AllocateBuffer method.
-        @ingroup buf
-     */
     OMX_ERRORTYPE (*AllocateBuffer)(
             OMX_IN OMX_HANDLETYPE hComponent,
             OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
@@ -494,69 +324,27 @@ typedef struct OMX_COMPONENTTYPE
             OMX_IN OMX_PTR pAppPrivate,
             OMX_IN OMX_U32 nSizeBytes);
 
-    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL 
-        specification for details on the FreeBuffer method.
-        @ingroup buf
-     */
     OMX_ERRORTYPE (*FreeBuffer)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_U32 nPortIndex,
             OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
 
-    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL 
-        specification for details on the EmptyThisBuffer method.
-        @ingroup buf
-     */
     OMX_ERRORTYPE (*EmptyThisBuffer)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
 
-    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL 
-        specification for details on the FillThisBuffer method.
-        @ingroup buf
-     */
     OMX_ERRORTYPE (*FillThisBuffer)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
 
-    /** The SetCallbacks method is used by the core to specify the callback
-        structure from the application to the component.  This is a blocking
-        call.  The component will return from this call within 5 msec.
-        @param [in] hComponent
-            Handle of the component to be accessed.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param [in] pCallbacks
-            pointer to an OMX_CALLBACKTYPE structure used to provide the 
-            callback information to the component
-        @param [in] pAppData
-            pointer to an application defined value.  It is anticipated that 
-            the application will pass a pointer to a data structure or a "this
-            pointer" in this area to allow the callback (in the application)
-            to determine the context of the call
-        @return OMX_ERRORTYPE
-            If the command successfully executes, the return code will be
-            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-     */
     OMX_ERRORTYPE (*SetCallbacks)(
             OMX_IN  OMX_HANDLETYPE hComponent,
             OMX_IN  OMX_CALLBACKTYPE* pCallbacks, 
             OMX_IN  OMX_PTR pAppData);
 
-    /** ComponentDeInit method is used to deinitialize the component
-        providing a means to free any resources allocated at component
-        initialization.  NOTE:  After this call the component handle is
-        not valid for further use.
-        @param [in] hComponent
-            Handle of the component to be accessed.  This is the component
-            handle returned by the call to the GetHandle function.
-        @return OMX_ERRORTYPE
-            If the command successfully executes, the return code will be
-            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-     */
     OMX_ERRORTYPE (*ComponentDeInit)(
             OMX_IN  OMX_HANDLETYPE hComponent);
 
-    /** @ingroup buf */
     OMX_ERRORTYPE (*UseEGLImage)(
             OMX_IN OMX_HANDLETYPE hComponent,
             OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
@@ -566,11 +354,85 @@ typedef struct OMX_COMPONENTTYPE
 
     OMX_ERRORTYPE (*ComponentRoleEnum)(
         OMX_IN OMX_HANDLETYPE hComponent,
-		OMX_OUT OMX_U8 *cRole,
-		OMX_IN OMX_U32 nIndex);
+        OMX_OUT OMX_U8 *cRole,
+        OMX_IN OMX_U32 nIndex);
 
 } OMX_COMPONENTTYPE;
 
+typedef struct OMX_CONFIG_COMMITMODETYPE { 
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_BOOL bDeferred; 
+} OMX_CONFIG_COMMITMODETYPE;
+
+typedef struct OMX_CONFIG_COMMITTYPE { 
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+} OMX_CONFIG_COMMITTYPE;
+
+typedef enum OMX_MEDIACONTAINER_FORMATTYPE { 
+    OMX_FORMAT_RAW = 0,
+    OMX_FORMAT_MP4,
+    OMX_FORMAT_3GP,
+    OMX_FORMAT_3G2,
+    OMX_FORMAT_AMC,
+    OMX_FORMAT_SKM,
+    OMX_FORMAT_K3G,
+    OMX_FORMAT_VOB,
+    OMX_FORMAT_AVI,
+    OMX_FORMAT_ASF,
+    OMX_FORMAT_RM,
+    OMX_FORMAT_MPEG_ES,
+    OMX_FORMAT_DIVX,
+    OMX_FORMAT_MPEG_TS,
+    OMX_FORMAT_QT,
+    OMX_FORMAT_M4A,
+    OMX_FORMAT_MP3,
+    OMX_FORMAT_WAVE,
+    OMX_FORMAT_XMF,
+    OMX_FORMAT_AMR,
+    OMX_FORMAT_AAC,
+    OMX_FORMAT_EVRC,
+    OMX_FORMAT_QCP,
+    OMX_FORMAT_SMF,
+    OMX_FORMAT_OGG,
+    OMX_FORMAT_BMP,
+    OMX_FORMAT_JPG,
+    OMX_FORMAT_JPG2000,
+    OMX_FORMAT_MKV,
+    OMX_FORMAT_FLV,
+    OMX_FORMAT_M4V,
+    OMX_FORMAT_F4V,
+    OMX_FORMAT_WEBM,
+    OMX_FORMAT_WEBP,
+    OMX_FORMATKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_FORMATVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FORMATMax= 0x7FFFFFFF
+} OMX_MEDIACONTAINER_FORMATTYPE;
+
+typedef struct OMX_MEDIACONTAINER_INFOTYPE {
+    OMX_U32  nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_MEDIACONTAINER_FORMATTYPE eFmtType;
+} OMX_MEDIACONTAINER_INFOTYPE;
+
+#define OMX_PORTSTATUS_ACCEPTUSEBUFFER      0x00000001
+#define OMX_PORTSTATUS_ACCEPTBUFFEREXCHANGE 0x00000002
+
+typedef struct OMX_CONFIG_TUNNELEDPORTSTATUSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nTunneledPortStatus;
+} OMX_CONFIG_TUNNELEDPORTSTATUSTYPE;
+
+typedef struct OMX_CONFIG_PORTBOOLEANTYPE{    
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnabled;
+} OMX_CONFIG_PORTBOOLEANTYPE;
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/omx/openmax/OMX_ComponentExt.h b/omx/openmax/OMX_ComponentExt.h
deleted file mode 100644
index e5aa748..0000000
--- a/omx/openmax/OMX_ComponentExt.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_ComponentExt.h - OpenMax IL version 1.1.2
- * The OMX_ComponentExt header file contains extensions to the definitions used
- * by both the application and the component to access common items.
- */
-
-#ifndef OMX_ComponentExt_h
-#define OMX_ComponentExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header must include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully 
- */
-#include <OMX_Types.h>
-
-
-/** Set/query the commit mode */
-typedef struct OMX_CONFIG_COMMITMODETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_BOOL bDeferred;
-} OMX_CONFIG_COMMITMODETYPE;
-
-/** Explicit commit */
-typedef struct OMX_CONFIG_COMMITTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-} OMX_CONFIG_COMMITTYPE;
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_ComponentExt_h */
diff --git a/omx/openmax/OMX_ContentPipe.h b/omx/openmax/OMX_ContentPipe.h
deleted file mode 100644
index 5f6310c..0000000
--- a/omx/openmax/OMX_ContentPipe.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** OMX_ContentPipe.h - OpenMax IL version 1.1.2
- *  The OMX_ContentPipe header file contains the definitions used to define
- *  the public interface for content piples.  This header file is intended to
- *  be used by the component.
- */
-
-#ifndef OMX_CONTENTPIPE_H
-#define OMX_CONTENTPIPE_H
-
-#ifndef KD_EACCES
-/* OpenKODE error codes. CPResult values may be zero (indicating success
-   or one of the following values) */
-#define KD_EACCES (1)
-#define KD_EADDRINUSE (2)
-#define KD_EAGAIN (5)
-#define KD_EBADF (7)
-#define KD_EBUSY (8)
-#define KD_ECONNREFUSED (9)
-#define KD_ECONNRESET (10)
-#define KD_EDEADLK (11)
-#define KD_EDESTADDRREQ (12)
-#define KD_ERANGE (35)
-#define KD_EEXIST (13)
-#define KD_EFBIG (14)
-#define KD_EHOSTUNREACH (15)
-#define KD_EINVAL (17)
-#define KD_EIO (18)
-#define KD_EISCONN (20)
-#define KD_EISDIR (21)
-#define KD_EMFILE (22)
-#define KD_ENAMETOOLONG (23)
-#define KD_ENOENT (24)
-#define KD_ENOMEM (25)
-#define KD_ENOSPC (26)
-#define KD_ENOSYS (27)
-#define KD_ENOTCONN (28)
-#define KD_EPERM (33)
-#define KD_ETIMEDOUT (36)
-#define KD_EILSEQ (19)
-#endif
-
-/** Map types from OMX standard types only here so interface is as generic as possible. */
-typedef OMX_U32    CPresult;
-typedef char *     CPstring;  
-typedef void *     CPhandle;
-typedef OMX_U32    CPuint;
-typedef OMX_S32    CPint;  
-typedef char       CPbyte;  
-typedef OMX_BOOL   CPbool;
-
-/** enumeration of origin types used in the CP_PIPETYPE's Seek function 
- * @ingroup cp
- */
-typedef enum CP_ORIGINTYPE {
-    CP_OriginBegin,      
-    CP_OriginCur,      
-    CP_OriginEnd,      
-    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_OriginMax = 0X7FFFFFFF
-} CP_ORIGINTYPE;
-
-/** enumeration of contact access types used in the CP_PIPETYPE's Open function 
- * @ingroup cp
- */
-typedef enum CP_ACCESSTYPE {
-    CP_AccessRead,      
-    CP_AccessWrite,  
-    CP_AccessReadWrite ,  
-    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_AccessMax = 0X7FFFFFFF
-} CP_ACCESSTYPE;
-
-/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function 
- * @ingroup cp
- */
-typedef enum CP_CHECKBYTESRESULTTYPE
-{
-    CP_CheckBytesOk,                    /**< There are at least the request number 
-                                              of bytes available */
-    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes 
-                                              and presently lacks sufficient bytes. 
-                                              Client will be called when they are 
-                                              sufficient bytes are available. */
-    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes 
-                                              but those available are less than those 
-                                              requested */
-    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
-                                              and no more bytes are available. */
-    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
-    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_CheckBytesMax = 0X7FFFFFFF
-} CP_CHECKBYTESRESULTTYPE;
-
-/** enumeration of content pipe events sent to the client callback. 
- * @ingroup cp
- */
-typedef enum CP_EVENTTYPE{
-    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
-    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
-    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
-    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_EventMax = 0X7FFFFFFF
-} CP_EVENTTYPE;
-
-/** content pipe definition 
- * @ingroup cp
- */
-typedef struct CP_PIPETYPE
-{
-    /** Open a content stream for reading or writing. */ 
-    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
-
-    /** Close a content stream. */ 
-    CPresult (*Close)( CPhandle hContent );
-
-    /** Create a content source and open it for writing. */ 
-    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
-
-    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
-    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
-
-    /** Seek to certain position in the content relative to the specified origin. */
-    CPresult (*SetPosition)( CPhandle  hContent, CPint nOffset, CP_ORIGINTYPE eOrigin);
-
-    /** Retrieve the current position relative to the start of the content. */
-    CPresult (*GetPosition)( CPhandle hContent, CPuint *pPosition);
-
-    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
-       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
-    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize); 
-
-    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes. 
-       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
-       returns the size of the block actually read. Content pointer advances the by the returned size. 
-       Note: pipe provides pointer. This function is appropriate for large reads. The client must call 
-       ReleaseReadBuffer when done with buffer. 
-
-       In some cases the requested block may not reside in contiguous memory within the
-       pipe implementation. For instance if the pipe leverages a circular buffer then the requested 
-       block may straddle the boundary of the circular buffer. By default a pipe implementation 
-       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
-       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory 
-       boundary. Here the client may retrieve the data in segments over successive calls. */
-    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
-
-    /** Release a buffer obtained by ReadBuffer back to the pipe. */
-    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
-
-    /** Write data of the specified size to the content (advance content pointer by size of data).
-       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
-    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize); 
-
-    /** Retrieve a buffer allocated by the pipe used to write data to the content. 
-       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
-       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
-    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
-
-    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the 
-       the contents of the buffer to content and advance content pointer by the size of the buffer */
-    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
-
-    /** Register a per-handle client callback with the content pipe. */
-    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
-
-} CP_PIPETYPE;
-
-#endif
-
diff --git a/omx/openmax/OMX_Core.h b/omx/openmax/OMX_Core.h
index d80c8a8..b2abe0a 100644
--- a/omx/openmax/OMX_Core.h
+++ b/omx/openmax/OMX_Core.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,9 +21,11 @@
  *
  */
 
-/** OMX_Core.h - OpenMax IL version 1.1.2
- *  The OMX_Core header file contains the definitions used by both the
- *  application and the component to access common items.
+/*
+ *  OMX_Core.h - OpenMax IL version 1.2.0
+ *  The OMX_Core header file contains the definitions used by
+ *  both the application and the component to access common
+ *  items.
  */
 
 #ifndef OMX_Core_h
@@ -41,494 +43,233 @@ extern "C" {
 
 #include <OMX_Index.h>
 
-
-/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
- *  OMX_SendCommand macro.  
- *  @ingroup core
- */
 typedef enum OMX_COMMANDTYPE
 {
-    OMX_CommandStateSet,    /**< Change the component state */
-    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
-    OMX_CommandPortDisable, /**< Disable a port on a component. */
-    OMX_CommandPortEnable,  /**< Enable a port on a component. */
-    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
+    OMX_CommandStateSet,
+    OMX_CommandFlush,
+    OMX_CommandPortDisable,
+    OMX_CommandPortEnable,
+    OMX_CommandMarkBuffer,
     OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_CommandMax = 0X7FFFFFFF
 } OMX_COMMANDTYPE;
 
-
-
-/** The OMX_STATETYPE enumeration is used to indicate or change the component
- *  state.  This enumeration reflects the current state of the component when
- *  used with the OMX_GetState macro or becomes the parameter in a state change
- *  command when used with the OMX_SendCommand macro.
- *
- *  The component will be in the Loaded state after the component is initially
- *  loaded into memory.  In the Loaded state, the component is not allowed to
- *  allocate or hold resources other than to build it's internal parameter
- *  and configuration tables.  The application will send one or more
- *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
- *  component and the component will record each of these parameter and
- *  configuration changes for use later.  When the application sends the
- *  Idle command, the component will acquire the resources needed for the
- *  specified configuration and will transition to the idle state if the
- *  allocation is successful.  If the component cannot successfully
- *  transition to the idle state for any reason, the state of the component
- *  shall be fully rolled back to the Loaded state (e.g. all allocated 
- *  resources shall be released).  When the component receives the command
- *  to go to the Executing state, it shall begin processing buffers by
- *  sending all input buffers it holds to the application.  While
- *  the component is in the Idle state, the application may also send the
- *  Pause command.  If the component receives the pause command while in the
- *  Idle state, the component shall send all input buffers it holds to the 
- *  application, but shall not begin processing buffers.  This will allow the
- *  application to prefill buffers.
- * 
- *  @ingroup comp
- */
-
 typedef enum OMX_STATETYPE
 {
-    OMX_StateInvalid,      /**< component has detected that it's internal data 
-                                structures are corrupted to the point that
-                                it cannot determine it's state properly */
-    OMX_StateLoaded,      /**< component has been loaded but has not completed
-                                initialization.  The OMX_SetParameter macro
-                                and the OMX_GetParameter macro are the only 
-                                valid macros allowed to be sent to the 
-                                component in this state. */
-    OMX_StateIdle,        /**< component initialization has been completed
-                                successfully and the component is ready to
-                                to start. */
-    OMX_StateExecuting,   /**< component has accepted the start command and
-                                is processing data (if data is available) */
-    OMX_StatePause,       /**< component has received pause command */
-    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
-                                preemption or before it gets the resources requested.
-                                See specification for complete details. */
+    OMX_StateReserved_0x00000000,
+    OMX_StateLoaded,
+    OMX_StateIdle,
+    OMX_StateExecuting,
+    OMX_StatePause,
+    OMX_StateWaitForResources,
     OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_StateMax = 0X7FFFFFFF
 } OMX_STATETYPE;
 
-/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
- *  errors should cover most of the common failure cases.  However, 
- *  vendors are free to add additional error messages of their own as 
- *  long as they follow these rules:
- *  1.  Vendor error messages shall be in the range of 0x90000000 to
- *      0x9000FFFF.
- *  2.  Vendor error messages shall be defined in a header file provided
- *      with the component.  No error messages are allowed that are
- *      not defined.
- */
 typedef enum OMX_ERRORTYPE
 {
   OMX_ErrorNone = 0,
 
-  /** There were insufficient resources to perform the requested operation */
   OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
 
-  /** There was an error, but the cause of the error could not be determined */
   OMX_ErrorUndefined = (OMX_S32) 0x80001001,
 
-  /** The component name string was not valid */
   OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
 
-  /** No component with the specified name string was found */
   OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
 
-  /** The component specified did not have a "OMX_ComponentInit" or
-      "OMX_ComponentDeInit entry point */
-  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
+  OMX_ErrorReserved_0x80001004 = (OMX_S32) 0x80001004,
 
-  /** One or more parameters were not valid */
   OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
 
-  /** The requested function is not implemented */
   OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
 
-  /** The buffer was emptied before the next buffer was ready */
   OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
 
-  /** The buffer was not available when it was needed */
   OMX_ErrorOverflow = (OMX_S32) 0x80001008,
 
-  /** The hardware failed to respond as expected */
   OMX_ErrorHardware = (OMX_S32) 0x80001009,
 
-  /** The component is in the state OMX_StateInvalid */
-  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
+  OMX_ErrorReserved_0x8000100A = (OMX_S32) 0x8000100A,
 
-  /** Stream is found to be corrupt */
   OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
 
-  /** Ports being connected are not compatible */
   OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
 
-  /** Resources allocated to an idle component have been
-      lost resulting in the component returning to the loaded state */
   OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
 
-  /** No more indicies can be enumerated */
   OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
 
-  /** The component detected a version mismatch */
   OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
 
-  /** The component is not ready to return data at this time */
   OMX_ErrorNotReady = (OMX_S32) 0x80001010,
 
-  /** There was a timeout that occurred */
   OMX_ErrorTimeout = (OMX_S32) 0x80001011,
 
-  /** This error occurs when trying to transition into the state you are already in */
   OMX_ErrorSameState = (OMX_S32) 0x80001012,
 
-  /** Resources allocated to an executing or paused component have been 
-      preempted, causing the component to return to the idle state */
   OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013, 
 
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
-      on a port restart) when it deems that it has waited an unusually long time for the supplier 
-      to send it an allocated buffer via a UseBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
-
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
-      on a port stop) when it deems that it has waited an unusually long time for the supplier 
-      to request the deallocation of a buffer header via a FreeBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
-
-  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the stopping of a port (either on a transition from the IDLE to LOADED 
-      state or a port stop) when it deems that it has waited an unusually long time for 
-      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
-
-  /** Attempting a state transtion that is not allowed */
+  OMX_ErrorReserved_0x80001014 = (OMX_S32) 0x80001014,
+
+  OMX_ErrorReserved_0x80001015 = (OMX_S32) 0x80001015,
+
+  OMX_ErrorReserved_0x80001016 = (OMX_S32) 0x80001016,
+
   OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
 
-  /* Attempting a command that is not allowed during the present state. */
   OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018, 
 
-  /** The values encapsulated in the parameter or config structure are not supported. */
   OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
 
-  /** The parameter or config indicated by the given index is not supported. */
   OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
 
-  /** The port index supplied is incorrect. */
   OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
 
-  /** The port has lost one or more of its buffers and it thus unpopulated. */
   OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
 
-  /** Component suspended due to temporary loss of resources */
   OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
 
-  /** Component suspended due to an inability to acquire dynamic resources */
   OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
 
-  /** When the macroblock error reporting is enabled the component returns new error 
-  for every frame that has errors */
   OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
 
-  /** A component reports this error when it cannot parse or determine the format of an input stream. */
   OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020, 
 
-  /** The content open operation failed. */
-  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
+  OMX_ErrorReserved_0x80001021 = (OMX_S32) 0x80001021,
 
-  /** The content creation operation failed. */
-  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
+  OMX_ErrorReserved_0x80001022 = (OMX_S32) 0x80001022,
 
-  /** Separate table information is being used */
   OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
 
-  /** Tunneling is unsupported by the component*/
   OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
 
+  OMX_ErrorInvalidMode = (OMX_S32) 0x80001025,
+
+  OMX_ErrorStreamCorruptStalled = (OMX_S32) 0x80001026,
+
+  OMX_ErrorStreamCorruptFatal = (OMX_S32) 0x80001027,
+
+  OMX_ErrorPortsNotConnected = (OMX_S32) 0x80001028,
+
+  OMX_ErrorContentURINotSpecified = (OMX_S32) 0x80001029,
+
+  OMX_ErrorContentURIError = (OMX_S32) 0x8000102A,
+
   OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_ErrorMax = 0x7FFFFFFF
 } OMX_ERRORTYPE;
 
-/** @ingroup core */
 typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
 
-/** @ingroup core */
 typedef struct OMX_COMPONENTREGISTERTYPE
 {
-  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
-  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
+  const char          * pName;
+  OMX_COMPONENTINITTYPE pInitialize;
 } OMX_COMPONENTREGISTERTYPE;
 
-/** @ingroup core */
 extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];
 
-/** @ingroup rpm */
 typedef struct OMX_PRIORITYMGMTTYPE {
- OMX_U32 nSize;             /**< size of the structure in bytes */
- OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
- OMX_U32 nGroupPriority;            /**< Priority of the component group */
- OMX_U32 nGroupID;                  /**< ID of the component group */
+ OMX_U32 nSize;
+ OMX_VERSIONTYPE nVersion;
+ OMX_U32 nGroupPriority;
+ OMX_U32 nGroupID;
 } OMX_PRIORITYMGMTTYPE;
 
-/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
 #define OMX_MAX_STRINGNAME_SIZE 128
 
-/** @ingroup comp */
 typedef struct OMX_PARAM_COMPONENTROLETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];
 } OMX_PARAM_COMPONENTROLETYPE;
 
-/** End of Stream Buffer Flag: 
-  *
-  * A component sets EOS when it has no more data to emit on a particular 
-  * output port. Thus an output port shall set EOS on the last buffer it 
-  * emits. A component's determination of when an output port should 
-  * cease sending data is implemenation specific.
-  * @ingroup buf
-  */
-
-#define OMX_BUFFERFLAG_EOS 0x00000001 
-
-/** Start Time Buffer Flag: 
- *
- * The source of a stream (e.g. a demux component) sets the STARTTIME
- * flag on the buffer that contains the starting timestamp for the
- * stream. The starting timestamp corresponds to the first data that
- * should be displayed at startup or after a seek.
- * The first timestamp of the stream is not necessarily the start time.
- * For instance, in the case of a seek to a particular video frame, 
- * the target frame may be an interframe. Thus the first buffer of 
- * the stream will be the intra-frame preceding the target frame and
- * the starttime will occur with the target frame (with any other
- * required frames required to reconstruct the target intervening).
- *
- * The STARTTIME flag is directly associated with the buffer's 
- * timestamp ' thus its association to buffer data and its 
- * propagation is identical to the timestamp's.
- *
- * When a Sync Component client receives a buffer with the 
- * STARTTIME flag it shall perform a SetConfig on its sync port 
- * using OMX_ConfigTimeClientStartTime and passing the buffer's
- * timestamp.
- * 
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_STARTTIME 0x00000002
-
- 
-
-/** Decode Only Buffer Flag: 
- *
- * The source of a stream (e.g. a demux component) sets the DECODEONLY
- * flag on any buffer that should shall be decoded but should not be
- * displayed. This flag is used, for instance, when a source seeks to 
- * a target interframe that requires the decode of frames preceding the 
- * target to facilitate the target's reconstruction. In this case the 
- * source would emit the frames preceding the target downstream 
- * but mark them as decode only.
- *
- * The DECODEONLY is associated with buffer data and propagated in a 
- * manner identical to the buffer timestamp.
- *
- * A component that renders data should ignore all buffers with 
- * the DECODEONLY flag set.
- * 
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_DECODEONLY 0x00000004
-
-
-/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
-
-/* End of Frame: The buffer contains exactly one end of frame and no data
- *  occurs after the end of frame. This flag is an optional hint. The absence
- *  of this flag does not imply the absence of an end of frame within the buffer. 
- * @ingroup buf
-*/
-#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
-
-/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
- *  a frame that has no dependency on any other frame information 
- *  @ingroup buf
- */
-#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
-
-/* Extra data present flag: there is extra data appended to the data stream
- * residing in the buffer 
- * @ingroup buf  
- */
-#define OMX_BUFFERFLAG_EXTRADATA 0x00000040
-
-/** Codec Config Buffer Flag: 
-* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
-* output port when all bytes in the buffer form part or all of a set of
-* codec specific configuration data.  Examples include SPS/PPS nal units
-* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
-* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets 
-* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
-* with frame data in the same buffer, and shall send all buffers
-* containing codec configuration bytes before any buffers containing
-* frame data that those configurations bytes describe.
-* If the stream format for a particular codec has a frame specific
-* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
-* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
-* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
- * @ingroup buf
- */
-#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080
-
+#define OMX_BUFFERFLAG_EOS              0x00000001 
+#define OMX_BUFFERFLAG_STARTTIME        0x00000002
+#define OMX_BUFFERFLAG_DECODEONLY       0x00000004
+#define OMX_BUFFERFLAG_DATACORRUPT      0x00000008
+#define OMX_BUFFERFLAG_ENDOFFRAME       0x00000010
+#define OMX_BUFFERFLAG_SYNCFRAME        0x00000020
+#define OMX_BUFFERFLAG_EXTRADATA        0x00000040
+#define OMX_BUFFERFLAG_CODECCONFIG      0x00000080
+#define OMX_BUFFERFLAG_TIMESTAMPINVALID 0x00000100
+#define OMX_BUFFERFLAG_READONLY         0x00000200
+#define OMX_BUFFERFLAG_ENDOFSUBFRAME    0x00000400
+#define OMX_BUFFERFLAG_SKIPFRAME        0x00000800
 
-
-/** @ingroup buf */
 typedef struct OMX_BUFFERHEADERTYPE
 {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
-                                     that is acting as the buffer */
-    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
-    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
-                                     buffer */
-    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
-                                     the start of the buffer */
-    OMX_PTR pAppPrivate;        /**< pointer to any data the application
-                                     wants to associate with this buffer */
-    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
-                                     wants to associate with this buffer */ 
-    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
-                                     wants to associate with this buffer */
-    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
-                                     wants to associate with this buffer */
-    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
-                                              mark event upon processing this buffer. */
-    OMX_PTR pMarkData;          /**< Application specific data associated with 
-                                     the mark sent on a mark event to disambiguate 
-                                     this mark from others. */
-    OMX_U32 nTickCount;         /**< Optional entry that the component and
-                                     application can update with a tick count
-                                     when they access the component.  This
-                                     value should be in microseconds.  Since
-                                     this is a value relative to an arbitrary
-                                     starting point, this value cannot be used 
-                                     to determine absolute time.  This is an
-                                     optional entry and not all components
-                                     will update it.*/
- OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
-                                     starting at the first logical sample 
-                                     boundary in the buffer. Timestamps of 
-                                     successive samples within the buffer may
-                                     be inferred by adding the duration of the 
-                                     of the preceding buffer to the timestamp
-                                     of the preceding buffer.*/
-  OMX_U32     nFlags;           /**< buffer specific flags */
-  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
-                                     this buffer */
-  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
-                                     this buffer */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U8* pBuffer;
+    OMX_U32 nAllocLen;
+    OMX_U32 nFilledLen;
+    OMX_U32 nOffset;
+    OMX_PTR pAppPrivate;
+    OMX_PTR pPlatformPrivate;
+    OMX_PTR pInputPortPrivate;
+    OMX_PTR pOutputPortPrivate;
+    OMX_HANDLETYPE hMarkTargetComponent;
+    OMX_PTR pMarkData;
+    OMX_U32 nTickCount;
+    OMX_TICKS nTimeStamp;
+    OMX_U32 nFlags;
+    OMX_U32 nOutputPortIndex;
+    OMX_U32 nInputPortIndex;
 } OMX_BUFFERHEADERTYPE;
 
-/** The OMX_EXTRADATATYPE enumeration is used to define the 
- * possible extra data payload types.
- * NB: this enum is binary backwards compatible with the previous
- * OMX_EXTRADATA_QUANT define.  This should be replaced with
- * OMX_ExtraDataQuantization.
- */
 typedef enum OMX_EXTRADATATYPE
 {
-   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */        
-   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
-   OMX_ExtraDataInterlaceFormat,                /**< Taken from OMX 1.2 hdr. For Interlace support - IMG */
+   OMX_ExtraDataNone = 0,
+   OMX_ExtraDataQuantization,
+   OMX_ExtraDataInterlaceFormat,
    OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMG_ExtraDataMultiView = 0x7FFFFFFE,     /**< ExtraData related to H264 MVC */
    OMX_ExtraDataMax = 0x7FFFFFFF
 } OMX_EXTRADATATYPE;
 
-
 typedef struct OMX_OTHER_EXTRADATATYPE  {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;               
     OMX_U32 nPortIndex;
-    OMX_EXTRADATATYPE eType;       /* Extra Data type */
-    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
-    OMX_U8  data[1];     /* Supporting data hint  */
+    OMX_EXTRADATATYPE eType;
+    OMX_U32 nDataSize;
+    OMX_U8  data[1];
 } OMX_OTHER_EXTRADATATYPE;
 
-/** @ingroup comp */
 typedef struct OMX_PORT_PARAM_TYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPorts;             /**< The number of ports for this component */
-    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPorts;
+    OMX_U32 nStartPortNumber;
 } OMX_PORT_PARAM_TYPE; 
 
-/** @ingroup comp */
 typedef enum OMX_EVENTTYPE
 {
-    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
-    OMX_EventError,               /**< component has detected an error condition */
-    OMX_EventMark,                /**< component has detected a buffer mark */
-    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
-    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
-    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
-                                       automatically starting the state change from
-                                       OMX_StateWaitForResources to OMX_StateIdle. */
-   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
-   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
-   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
-   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_EventMax = 0x7FFFFFFF
+    OMX_EventCmdComplete,
+    OMX_EventError,
+    OMX_EventMark,
+    OMX_EventPortSettingsChanged,
+    OMX_EventBufferFlag,
+    OMX_EventResourcesAcquired,
+    OMX_EventComponentResumed,
+    OMX_EventDynamicResourcesAvailable,
+    OMX_EventPortFormatDetected,
+    OMX_EventIndexSettingChanged,
+    OMX_EventPortNeedsDisable,
+    OMX_EventPortNeedsFlush,
+    OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EventMax = 0x7FFFFFFF
 } OMX_EVENTTYPE;
 
 typedef struct OMX_CALLBACKTYPE
 {
-    /** The EventHandler method is used to notify the application when an
-        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
-        enumeration.  Please see that enumeration for details of what will
-        be returned for each type of event. Callbacks should not return
-        an error to the component, so if an error occurs, the application 
-        shall handle it internally.  This is a blocking call.
-
-        The application should return from this call within 5 msec to avoid
-        blocking the component for an excessively long period of time.
-
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the 
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
-            can have a component specific context when receiving the callback.
-        @param eEvent
-            Event that the component wants to notify the application about.
-        @param nData1
-            nData will be the OMX_ERRORTYPE for an error event and will be 
-            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
-         @param nData2
-            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
-            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
-            Default value is 0 if not used. )
-        @param pEventData
-            Pointer to additional event-specific data (see spec for meaning).
-      */
-
    OMX_ERRORTYPE (*EventHandler)(
         OMX_IN OMX_HANDLETYPE hComponent,
         OMX_IN OMX_PTR pAppData,
@@ -536,153 +277,42 @@ typedef struct OMX_CALLBACKTYPE
         OMX_IN OMX_U32 nData1,
         OMX_IN OMX_U32 nData2,
         OMX_IN OMX_PTR pEventData);
-
-    /** The EmptyBufferDone method is used to return emptied buffers from an
-        input port back to the application for reuse.  This is a blocking call 
-        so the application should not attempt to refill the buffers during this
-        call, but should queue them and refill them in another thread.  There
-        is no error return, so the application shall handle any errors generated
-        internally.  
-        
-        The application should return from this call within 5 msec.
-        
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the 
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
-            can have a component specific context when receiving the callback.
-        @param pBuffer
-            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-            or AllocateBuffer indicating the buffer that was emptied.
-        @ingroup buf
-     */
     OMX_ERRORTYPE (*EmptyBufferDone)(
         OMX_IN OMX_HANDLETYPE hComponent,
         OMX_IN OMX_PTR pAppData,
         OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
-
-    /** The FillBufferDone method is used to return filled buffers from an
-        output port back to the application for emptying and then reuse.  
-        This is a blocking call so the application should not attempt to 
-        empty the buffers during this call, but should queue the buffers 
-        and empty them in another thread.  There is no error return, so 
-        the application shall handle any errors generated internally.  The 
-        application shall also update the buffer header to indicate the
-        number of bytes placed into the buffer.  
-
-        The application should return from this call within 5 msec.
-        
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the 
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
-            can have a component specific context when receiving the callback.
-        @param pBuffer
-            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-            or AllocateBuffer indicating the buffer that was filled.
-        @ingroup buf
-     */
     OMX_ERRORTYPE (*FillBufferDone)(
-        OMX_OUT OMX_HANDLETYPE hComponent,
-        OMX_OUT OMX_PTR pAppData,
-        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
 
 } OMX_CALLBACKTYPE;
 
-/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
-    preference when tunneling between two ports.
-    @ingroup tun buf
-*/
 typedef enum OMX_BUFFERSUPPLIERTYPE
 {
-    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
-                                              or don't care */
-    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
-    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
+    OMX_BufferSupplyUnspecified = 0x0,
+    OMX_BufferSupplyInput,
+    OMX_BufferSupplyOutput,
     OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_BufferSupplyMax = 0x7FFFFFFF
 } OMX_BUFFERSUPPLIERTYPE;
 
-
-/** buffer supplier parameter 
- * @ingroup tun
- */
 typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
-    OMX_U32 nSize; /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex; /**< port that this structure applies to */
-    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BUFFERSUPPLIERTYPE eBufferSupplier;
 } OMX_PARAM_BUFFERSUPPLIERTYPE;
 
-
-/**< indicates that buffers received by an input port of a tunnel 
-     may not modify the data in the buffers 
-     @ingroup tun
- */
 #define OMX_PORTTUNNELFLAG_READONLY 0x00000001 
 
-
-/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
-    port to an input port as part the two ComponentTunnelRequest calls
-    resulting from a OMX_SetupTunnel call from the IL Client. 
-    @ingroup tun
- */   
 typedef struct OMX_TUNNELSETUPTYPE
 {
-    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
-    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
+    OMX_U32 nTunnelFlags;
+    OMX_BUFFERSUPPLIERTYPE eSupplier;
 } OMX_TUNNELSETUPTYPE; 
 
-/* OMX Component headers is included to enable the core to use
-   macros for functions into the component for OMX release 1.0.  
-   Developers should not access any structures or data from within
-   the component header directly */
-/* TO BE REMOVED - #include <OMX_Component.h> */
-
-/** GetComponentVersion will return information about the component.  
-    This is a blocking call.  This macro will go directly from the
-    application to the component (via a core macro).  The
-    component will return from this call within 5 msec.
-    @param [in] hComponent
-        handle of component to execute the command
-    @param [out] pComponentName
-        pointer to an empty string of length 128 bytes.  The component 
-        will write its name into this string.  The name will be 
-        terminated by a single zero byte.  The name of a component will 
-        be 127 bytes or less to leave room for the trailing zero byte.  
-        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
-    @param [out] pComponentVersion
-        pointer to an OMX Version structure that the component will fill 
-        in.  The component will fill in a value that indicates the 
-        component version.  NOTE: the component version is NOT the same 
-        as the OMX Specification version (found in all structures).  The 
-        component version is defined by the vendor of the component and 
-        its value is entirely up to the component vendor.
-    @param [out] pSpecVersion
-        pointer to an OMX Version structure that the component will fill 
-        in.  The SpecVersion is the version of the specification that the 
-        component was built against.  Please note that this value may or 
-        may not match the structure's version.  For example, if the 
-        component was built against the 2.0 specification, but the 
-        application (which creates the structure is built against the 
-        1.0 specification the versions would be different.
-    @param [out] pComponentUUID
-        pointer to the UUID of the component which will be filled in by 
-        the component.  The UUID is a unique identifier that is set at 
-        RUN time for the component and is unique to each instantion of 
-        the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
 #define OMX_GetComponentVersion(                            \
         hComponent,                                         \
         pComponentName,                                     \
@@ -694,56 +324,8 @@ typedef struct OMX_TUNNELSETUPTYPE
         pComponentName,                                     \
         pComponentVersion,                                  \
         pSpecVersion,                                       \
-        pComponentUUID)                 /* Macro End */
+        pComponentUUID)
 
-
-/** Send a command to the component.  This call is a non-blocking call.
-    The component should check the parameters and then queue the command
-    to the component thread to be executed.  The component thread shall 
-    send the EventHandler() callback at the conclusion of the command. 
-    This macro will go directly from the application to the component (via
-    a core macro).  The component will return from this call within 5 msec.
-    
-    When the command is "OMX_CommandStateSet" the component will queue a
-    state transition to the new state idenfied in nParam.
-    
-    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
-    the command will force the component to return all buffers NOT CURRENTLY 
-    BEING PROCESSED to the application, in the order in which the buffers 
-    were received.
-    
-    When the command is "OMX_CommandPortDisable" or 
-    "OMX_CommandPortEnable", the component's port (given by the value of
-    nParam) will be stopped or restarted. 
-    
-    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
-    pCmdData will point to a OMX_MARKTYPE structure containing the component
-    handle of the component to examine the buffer chain for the mark.  nParam1
-    contains the index of the port on which the buffer mark is applied.
-
-    Specification text for more details. 
-    
-    @param [in] hComponent
-        handle of component to execute the command
-    @param [in] Cmd
-        Command for the component to execute
-    @param [in] nParam
-        Parameter for the command to be executed.  When Cmd has the value 
-        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has 
-        the value OMX_CommandFlush, value of nParam indicates which port(s) 
-        to flush. -1 is used to flush all ports a single port index will 
-        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
-        or "OMX_CommandPortEnable", the component's port is given by 
-        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
-        the components pot is given by the value of nParam.
-    @param [in] pCmdData
-        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
-        "OMX_CommandMarkBuffer".     
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
 #define OMX_SendCommand(                                    \
          hComponent,                                        \
          Cmd,                                               \
@@ -753,38 +335,8 @@ typedef struct OMX_TUNNELSETUPTYPE
          hComponent,                                        \
          Cmd,                                               \
          nParam,                                            \
-         pCmdData)                          /* Macro End */
-
-
-/** The OMX_GetParameter macro will get one of the current parameter 
-    settings from the component.  This macro cannot only be invoked when 
-    the component is in the OMX_StateInvalid state.  The nParamIndex
-    parameter is used to indicate which structure is being requested from
-    the component.  The application shall allocate the correct structure 
-    and shall fill in the structure size and version information before 
-    invoking this macro.  When the parameter applies to a port, the
-    caller shall fill in the appropriate nPortIndex value indicating the
-    port on which the parameter applies. If the component has not had 
-    any settings changed, then the component should return a set of 
-    valid DEFAULT  parameters for the component.  This is a blocking 
-    call.  
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nParamIndex
-        Index of the structure to be filled.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in,out] pComponentParameterStructure
-        Pointer to application allocated structure to be filled by the 
-        component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
+         pCmdData)
+
 #define OMX_GetParameter(                                   \
         hComponent,                                         \
         nParamIndex,                                        \
@@ -792,38 +344,8 @@ typedef struct OMX_TUNNELSETUPTYPE
     ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
         hComponent,                                         \
         nParamIndex,                                        \
-        pComponentParameterStructure)    /* Macro End */
-
-
-/** The OMX_SetParameter macro will send an initialization parameter
-    structure to a component.  Each structure shall be sent one at a time,
-    in a separate invocation of the macro.  This macro can only be
-    invoked when the component is in the OMX_StateLoaded state, or the
-    port is disabled (when the parameter applies to a port). The 
-    nParamIndex parameter is used to indicate which structure is being
-    passed to the component.  The application shall allocate the 
-    correct structure and shall fill in the structure size and version 
-    information (as well as the actual data) before invoking this macro.
-    The application is free to dispose of this structure after the call
-    as the component is required to copy any data it shall retain.  This 
-    is a blocking call.  
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nIndex
-        Index of the structure to be sent.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in] pComponentParameterStructure
-        pointer to application allocated structure to be used for
-        initialization by the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
+        pComponentParameterStructure)
+
 #define OMX_SetParameter(                                   \
         hComponent,                                         \
         nParamIndex,                                        \
@@ -831,35 +353,8 @@ typedef struct OMX_TUNNELSETUPTYPE
     ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
         hComponent,                                         \
         nParamIndex,                                        \
-        pComponentParameterStructure)    /* Macro End */
-
-
-/** The OMX_GetConfig macro will get one of the configuration structures 
-    from a component.  This macro can be invoked anytime after the 
-    component has been loaded.  The nParamIndex call parameter is used to 
-    indicate which structure is being requested from the component.  The 
-    application shall allocate the correct structure and shall fill in the 
-    structure size and version information before invoking this macro.  
-    If the component has not had this configuration parameter sent before, 
-    then the component should return a set of valid DEFAULT values for the 
-    component.  This is a blocking call.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nIndex
-        Index of the structure to be filled.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in,out] pComponentConfigStructure
-        pointer to application allocated structure to be filled by the 
-        component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
-*/        
+        pComponentParameterStructure)
+
 #define OMX_GetConfig(                                      \
         hComponent,                                         \
         nConfigIndex,                                       \
@@ -867,35 +362,8 @@ typedef struct OMX_TUNNELSETUPTYPE
     ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
         hComponent,                                         \
         nConfigIndex,                                       \
-        pComponentConfigStructure)       /* Macro End */
-
-
-/** The OMX_SetConfig macro will send one of the configuration 
-    structures to a component.  Each structure shall be sent one at a time,
-    each in a separate invocation of the macro.  This macro can be invoked 
-    anytime after the component has been loaded.  The application shall 
-    allocate the correct structure and shall fill in the structure size 
-    and version information (as well as the actual data) before invoking 
-    this macro.  The application is free to dispose of this structure after 
-    the call as the component is required to copy any data it shall retain.  
-    This is a blocking call.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nConfigIndex
-        Index of the structure to be sent.  This value is from the
-        OMX_INDEXTYPE enumeration above.
-    @param [in] pComponentConfigStructure
-        pointer to application allocated structure to be used for
-        initialization by the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
+        pComponentConfigStructure)
+
 #define OMX_SetConfig(                                      \
         hComponent,                                         \
         nConfigIndex,                                       \
@@ -903,33 +371,8 @@ typedef struct OMX_TUNNELSETUPTYPE
     ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
         hComponent,                                         \
         nConfigIndex,                                       \
-        pComponentConfigStructure)       /* Macro End */
-
+        pComponentConfigStructure)
 
-/** The OMX_GetExtensionIndex macro will invoke a component to translate 
-    a vendor specific configuration or parameter string into an OMX 
-    structure index.  There is no requirement for the vendor to support 
-    this command for the indexes already found in the OMX_INDEXTYPE 
-    enumeration (this is done to save space in small components).  The 
-    component shall support all vendor supplied extension indexes not found
-    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the GetHandle function.
-    @param [in] cParameterName
-        OMX_STRING that shall be less than 128 characters long including
-        the trailing null byte.  This is the string that will get 
-        translated by the component into a configuration index.
-    @param [out] pIndexType
-        a pointer to a OMX_INDEXTYPE to receive the index value.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
 #define OMX_GetExtensionIndex(                              \
         hComponent,                                         \
         cParameterName,                                     \
@@ -937,96 +380,30 @@ typedef struct OMX_TUNNELSETUPTYPE
     ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
         hComponent,                                         \
         cParameterName,                                     \
-        pIndexType)                     /* Macro End */
-
+        pIndexType)
 
-/** The OMX_GetState macro will invoke the component to get the current 
-    state of the component and place the state value into the location
-    pointed to by pState.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] pState
-        pointer to the location to receive the state.  The value returned
-        is one of the OMX_STATETYPE members 
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
 #define OMX_GetState(                                       \
         hComponent,                                         \
         pState)                                             \
     ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
         hComponent,                                         \
-        pState)                         /* Macro End */
-
-
-/** The OMX_UseBuffer macro will request that the component use
-    a buffer (and allocate its own buffer header) already allocated 
-    by another component, or by the IL Client. This is a blocking 
-    call.
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
-        pointer to the buffer header
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
+        pState)
 
 #define OMX_UseBuffer(                                      \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           nSizeBytes,                                      \
-           pBuffer)                                         \
+        hComponent,                                         \
+        ppBufferHdr,                                        \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes,                                         \
+        pBuffer)                                            \
     ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           nSizeBytes,                                      \
-           pBuffer)
-
-
-/** The OMX_AllocateBuffer macro will request that the component allocate 
-    a new buffer and buffer header.  The component will allocate the 
-    buffer and the buffer header and return a pointer to the buffer 
-    header.  This is a blocking call.
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
-        the pointer to the buffer header
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.  The port can be found by using the nPortIndex
-        value as an index into the Port Definition array of the component.
-    @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the 
-        buffer header structure.
-    @param [in] nSizeBytes
-        size of the buffer to allocate.  Used when bAllocateNew is true.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */    
+        hComponent,                                         \
+        ppBufferHdr,                                        \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes,                                         \
+        pBuffer)
+
 #define OMX_AllocateBuffer(                                 \
         hComponent,                                         \
         ppBuffer,                                           \
@@ -1038,31 +415,8 @@ typedef struct OMX_TUNNELSETUPTYPE
         ppBuffer,                                           \
         nPortIndex,                                         \
         pAppPrivate,                                        \
-        nSizeBytes)                     /* Macro End */
-
+        nSizeBytes)
 
-/** The OMX_FreeBuffer macro will release a buffer header from the component
-    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
-    the component allocated the buffer (see the OMX_UseBuffer macro) then 
-    the component shall free the buffer and buffer header. This is a 
-    blocking call. 
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
 #define OMX_FreeBuffer(                                     \
         hComponent,                                         \
         nPortIndex,                                         \
@@ -1070,359 +424,99 @@ typedef struct OMX_TUNNELSETUPTYPE
     ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
         hComponent,                                         \
         nPortIndex,                                         \
-        pBuffer)                        /* Macro End */
+        pBuffer)
 
-
-/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
-    input port of a component.  The buffer will be emptied by the component
-    and returned to the application via the EmptyBufferDone call back.
-    This is a non-blocking call in that the component will record the buffer
-    and return immediately and then empty the buffer, later, at the proper 
-    time.  As expected, this macro may be invoked only while the component 
-    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
-    port, the component shall return an error.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
 #define OMX_EmptyThisBuffer(                                \
         hComponent,                                         \
         pBuffer)                                            \
     ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
         hComponent,                                         \
-        pBuffer)                        /* Macro End */
-
+        pBuffer)
 
-/** The OMX_FillThisBuffer macro will send an empty buffer to an 
-    output port of a component.  The buffer will be filled by the component
-    and returned to the application via the FillBufferDone call back.
-    This is a non-blocking call in that the component will record the buffer
-    and return immediately and then fill the buffer, later, at the proper 
-    time.  As expected, this macro may be invoked only while the component 
-    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
-    port, the component shall return an error.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
 #define OMX_FillThisBuffer(                                 \
         hComponent,                                         \
         pBuffer)                                            \
     ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
         hComponent,                                         \
-        pBuffer)                        /* Macro End */
+        pBuffer)
 
-
-
-/** The OMX_UseEGLImage macro will request that the component use
-    a EGLImage provided by EGL (and allocate its own buffer header)
-    This is a blocking call.
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
-        pointer to the buffer header.  Note that the memory location used
-        for this buffer is NOT visible to the IL Client.
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.  The port can be found by using the nPortIndex
-        value as an index into the Port Definition array of the component.
-    @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the 
-        buffer header structure.
-    @param [in] eglImage
-        eglImage contains the handle of the EGLImage to use as a buffer on the
-        specified port.  The component is expected to validate properties of 
-        the EGLImage against the configuration of the port to ensure the component
-        can use the EGLImage as a buffer.          
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
 #define OMX_UseEGLImage(                                    \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           eglImage)                                        \
+        hComponent,                                         \
+        ppBufferHdr,                                        \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        eglImage)                                           \
     ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           eglImage)
-
-/** The OMX_Init method is used to initialize the OMX core.  It shall be the
-    first call made into OMX and it should only be executed one time without
-    an interviening OMX_Deinit call.  
-    
-    The core should return from this call within 20 msec.
+        hComponent,                                         \
+        ppBufferHdr,                                        \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        eglImage)
 
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
+#define OMX_SetCallbacks(                                   \
+        hComponent,                                         \
+        pCallbacks,                                         \
+        pAppData)                                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetCallbacks(         \
+        hComponent,                                         \
+        pCallbacks,                                         \
+        pAppData)
 
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
 
-/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
-    the last call made into OMX. In the event that the core determines that 
-    thare are components loaded when this call is made, the core may return 
-    with an error rather than try to unload the components.
-        
-    The core should return from this call within 20 msec.
-    
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
 OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);
 
-
-/** The OMX_ComponentNameEnum method will enumerate through all the names of
-    recognised valid components in the system. This function is provided
-    as a means to detect all the components in the system run-time. There is
-    no strict ordering to the enumeration order of component names, although
-    each name will only be enumerated once.  If the OMX core supports run-time
-    installation of new components, it is only requried to detect newly
-    installed components when the first call to enumerate component names
-    is made (i.e. when nIndex is 0x0).
-    
-    The core should return from this call in 20 msec.
-    
-    @param [out] cComponentName
-        pointer to a null terminated string with the component name.  The
-        names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example 
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
-        assigned by the vendor, but shall start with "OMX." and then have 
-        the Vendor designation next.
-    @param [in] nNameLength
-        number of characters in the cComponentName string.  With all 
-        component name strings restricted to less than 128 characters 
-        (including the trailing null) it is recomended that the caller
-        provide a input string for the cComponentName of 128 characters.
-    @param [in] nIndex
-        number containing the enumeration index for the component. 
-        Multiple calls to OMX_ComponentNameEnum with increasing values
-        of nIndex will enumerate through the component names in the
-        system until OMX_ErrorNoMore is returned.  The value of nIndex
-        is 0 to (N-1), where N is the number of valid installed components
-        in the system.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  When the value of nIndex exceeds the number of 
-        components in the system minus 1, OMX_ErrorNoMore will be
-        returned. Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
 OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
     OMX_OUT OMX_STRING cComponentName,
     OMX_IN  OMX_U32 nNameLength,
     OMX_IN  OMX_U32 nIndex);
 
-
-/** The OMX_GetHandle method will locate the component specified by the
-    component name given, load that component into memory and then invoke
-    the component's methods to create an instance of the component.  
-    
-    The core should return from this call within 20 msec.
-    
-    @param [out] pHandle
-        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
-    @param [in] cComponentName
-        pointer to a null terminated string with the component name.  The
-        names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example 
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
-        assigned by the vendor, but shall start with "OMX." and then have 
-        the Vendor designation next.
-    @param [in] pAppData
-        pointer to an application defined value that will be returned
-        during callbacks so that the application can identify the source
-        of the callback.
-    @param [in] pCallBacks
-        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
-        component to initialize it with.  
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
 OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
     OMX_OUT OMX_HANDLETYPE* pHandle, 
     OMX_IN  OMX_STRING cComponentName,
     OMX_IN  OMX_PTR pAppData,
     OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
 
-
-/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
-    method.  If the component reference count goes to zero, the component will
-    be unloaded from memory.  
-    
-    The core should return from this call within 20 msec when the component is 
-    in the OMX_StateLoaded state.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the GetHandle function.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
 OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
     OMX_IN  OMX_HANDLETYPE hComponent);
 
-
-
-/** The OMX_SetupTunnel method will handle the necessary calls to the components
-    to setup the specified tunnel the two components.  NOTE: This is
-    an actual method (not a #define macro).  This method will make calls into
-    the component ComponentTunnelRequest method to do the actual tunnel 
-    connection.  
-
-    The ComponentTunnelRequest method on both components will be called. 
-    This method shall not be called unless the component is in the 
-    OMX_StateLoaded state except when the ports used for the tunnel are
-    disabled. In this case, the component may be in the OMX_StateExecuting,
-    OMX_StatePause, or OMX_StateIdle states. 
-
-    The core should return from this call within 20 msec.
-    
-    @param [in] hOutput
-        Handle of the component to be accessed.  Also this is the handle
-        of the component whose port, specified in the nPortOutput parameter
-        will be used the source for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a 
-        requirement that hOutput be the source for the data when
-        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
-        specified in hInput will have it's port specified in nPortInput
-        setup for communication with the application / IL client.
-    @param [in] nPortOutput
-        nPortOutput is used to select the source port on component to be
-        used in the tunnel. 
-    @param [in] hInput
-        This is the component to setup the tunnel with. This is the handle
-        of the component whose port, specified in the nPortInput parameter
-        will be used the destination for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a 
-        requirement that hInput be the destination for the data when
-        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
-        specified in hOutput will have it's port specified in nPortPOutput
-        setup for communication with the application / IL client.
-    @param [in] nPortInput
-        nPortInput is used to select the destination port on component to be
-        used in the tunnel.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-        When OMX_ErrorNotImplemented is returned, one or both components is 
-        a non-interop component and does not support tunneling.
-        
-        On failure, the ports of both components are setup for communication
-        with the application / IL Client.
-    @ingroup core tun
- */
 OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
     OMX_IN  OMX_HANDLETYPE hOutput,
     OMX_IN  OMX_U32 nPortOutput,
     OMX_IN  OMX_HANDLETYPE hInput,
     OMX_IN  OMX_U32 nPortInput);
     
-/** @ingroup cp */
-OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
-    OMX_OUT OMX_HANDLETYPE *hPipe,
-    OMX_IN OMX_STRING szURI);
-
-/** The OMX_GetComponentsOfRole method will return the number of components that support the given
-    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
-    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
-    client should:
-        * first call this function with the compNames field NULL to determine the number of component names
-        * second call this function with the compNames field pointing to an array of names allocated 
-          according to the number returned by the first call.
-
-    The core should return from this call within 5 msec.
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_TeardownTunnel(
+    OMX_IN  OMX_HANDLETYPE hOutput,
+    OMX_IN  OMX_U32 nPortOutput,
+    OMX_IN  OMX_HANDLETYPE hInput,
+    OMX_IN  OMX_U32 nPortInput);
     
-    @param [in] role
-        This is generic standard component name consisting only of component class 
-        name and the type within that class (e.g. 'audio_decoder.aac').
-    @param [inout] pNumComps
-        This is used both as input and output. 
- 
-        If compNames is NULL, the input is ignored and the output specifies how many components support
-        the given role.
-     
-        If compNames is not NULL, on input it bounds the size of the input structure and 
-        on output, it specifies the number of components string names listed within the compNames parameter.
-    @param [inout] compNames
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
-        a list of the names of all physical components that implement the specified standard component name. 
-        Each name is NULL terminated. numComps indicates the number of names.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
-	OMX_IN      OMX_STRING role,
-    OMX_INOUT   OMX_U32 *pNumComps,
-    OMX_INOUT   OMX_U8  **compNames);
-
-/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
-    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
-    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
-    client should:
-        * first call this function with the roles field NULL to determine the number of role names
-        * second call this function with the roles field pointing to an array of names allocated 
-          according to the number returned by the first call.
-
-    The core should return from this call within 5 msec.
-
-    @param [in] compName
-        This is the name of the component being queried about.
-    @param [inout] pNumRoles
-        This is used both as input and output. 
- 
-        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
-     
-        If compNames is not NULL, on input it bounds the size of the input structure and 
-        on output, it specifies the number of roles string names listed within the roles parameter.
-    @param [out] roles
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
-        which accepts a list of the names of all standard components roles implemented on the 
-        specified component name. numComps indicates the number of names.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
-	OMX_IN      OMX_STRING compName, 
-    OMX_INOUT   OMX_U32 *pNumRoles,
-    OMX_OUT     OMX_U8 **roles);
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentOfRoleEnum(
+    OMX_OUT OMX_STRING compName,
+    OMX_IN  OMX_STRING role,
+    OMX_IN  OMX_U32 nIndex);
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_RoleOfComponentEnum(
+    OMX_OUT OMX_STRING role,
+    OMX_IN  OMX_STRING compName,
+    OMX_IN  OMX_U32 nIndex);
+
+typedef struct OMX_CONFIG_CALLBACKREQUESTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_INDEXTYPE nIndex;
+    OMX_BOOL bEnable;
+} OMX_CONFIG_CALLBACKREQUESTTYPE;
+
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetCoreInterface(
+    OMX_OUT void ** ppItf,
+    OMX_IN OMX_STRING cExtensionName);
+
+OMX_API void OMX_APIENTRY OMX_FreeCoreInterface(
+    OMX_IN void * pItf);
 
 #ifdef __cplusplus
 }
diff --git a/omx/openmax/OMX_CoreExt.h b/omx/openmax/OMX_CoreExt.h
deleted file mode 100644
index b7a5b62..0000000
--- a/omx/openmax/OMX_CoreExt.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_CoreExt.h - OpenMax IL version 1.1.2
- * The OMX_CoreExt header file contains extensions to the definitions used
- * by both the application and the component to access common items.
- */
-
-#ifndef OMX_CoreExt_h
-#define OMX_CoreExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Core.h>
-
-/** Extensions to the standard IL errors. */ 
-typedef enum OMX_ERROREXTTYPE 
-{
-    OMX_ErrorInvalidMode = (OMX_S32) (OMX_ErrorKhronosExtensions + 0x00000001),
-    OMX_ErrorExtMax = 0x7FFFFFFF
-} OMX_ERROREXTTYPE;
-
-
-/** Event type extensions. */
-typedef enum OMX_EVENTEXTTYPE
-{
-    OMX_EventIndexSettingChanged = OMX_EventKhronosExtensions, /**< component signals the IL client of a change
-                                                                    in a param, config, or extension */
-    OMX_EventExtMax = 0x7FFFFFFF
-} OMX_EVENTEXTTYPE;
-
-
-/** Enable or disable a callback event. */
-typedef struct OMX_CONFIG_CALLBACKREQUESTTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_INDEXTYPE nIndex;       /**< the index the callback is requested for */
-    OMX_BOOL bEnable;           /**< enable (OMX_TRUE) or disable (OMX_FALSE) the callback */
-} OMX_CONFIG_CALLBACKREQUESTTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_CoreExt_h */
-/* File EOF */
diff --git a/omx/openmax/OMX_IVCommon.h b/omx/openmax/OMX_IVCommon.h
index 4c4995c..f51dd30 100644
--- a/omx/openmax/OMX_IVCommon.h
+++ b/omx/openmax/OMX_IVCommon.h
@@ -1,5 +1,5 @@
-/**
- * Copyright (c) 2008 The Khronos Group Inc. 
+/*
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,11 +21,12 @@
  *
  */
 
-/** 
- * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
+/*
+ *  OMX_IVCommon.h - OpenMax IL version 1.2.0
  *  The structures needed by Video and Image components to exchange
  *  parameters and configuration data with the components.
  */
+
 #ifndef OMX_IVCommon_h
 #define OMX_IVCommon_h
 
@@ -41,50 +42,6 @@ extern "C" {
 
 #include <OMX_Core.h>
 
-/** @defgroup iv OpenMAX IL Imaging and Video Domain
- * Common structures for OpenMAX IL Imaging and Video domains
- * @{
- */
-
-
-/** 
- * Enumeration defining possible uncompressed image/video formats. 
- *
- * ENUMS:
- *  Unused                 : Placeholder value when format is N/A
- *  Monochrome             : black and white
- *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
- *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
- *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
- *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
- *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
- *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
- *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
- *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
- *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
- *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
- *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
- *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
- *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
- *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
- *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
- *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
- *  YUV411PackedPlanar     : packed per payload in planar slices
- *  YUV420Planar           : Three arrays Y,U,V.
- *  YUV420PackedPlanar     : packed per payload in planar slices
- *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
- *  YUV422Planar           : Three arrays Y,U,V.
- *  YUV422PackedPlanar     : packed per payload in planar slices
- *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
- *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
- *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
- *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
- *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
- *  YUV444Interleaved      : Each pixel contains equal parts YUV
- *  RawBayer8bit           : SMIA camera output format
- *  RawBayer10bit          : SMIA camera output format
- *  RawBayer8bitcompressed : SMIA camera output format
- */
 typedef enum OMX_COLOR_FORMATTYPE {
     OMX_COLOR_FormatUnused,
     OMX_COLOR_FormatMonochrome,
@@ -130,43 +87,46 @@ typedef enum OMX_COLOR_FORMATTYPE {
     OMX_COLOR_Format18BitBGR666,
     OMX_COLOR_Format24BitARGB6666,
     OMX_COLOR_Format24BitABGR6666,
+    OMX_COLOR_Format32bitABGR8888,
+    OMX_COLOR_FormatYVU420Planar,
+    OMX_COLOR_FormatYVU420PackedPlanar,
+    OMX_COLOR_FormatYVU420SemiPlanar,
+    OMX_COLOR_FormatYVU420PackedSemiPlanar,
+    OMX_COLOR_FormatYVU422Planar,
+    OMX_COLOR_FormatYVU422PackedPlanar,
+    OMX_COLOR_FormatYVU422SemiPlanar,
+    OMX_COLOR_FormatYVU422PackedSemiPlanar,
+    OMX_COLOR_Format8bitBGR233,
+    OMX_COLOR_Format12bitBGR444,
+    OMX_COLOR_Format16bitBGRA4444,
+    OMX_COLOR_Format16bitBGRA5551,
+    OMX_COLOR_Format18bitBGRA5661,
+    OMX_COLOR_Format19bitBGRA6661,
+    OMX_COLOR_Format24bitBGRA7881,
+    OMX_COLOR_Format25bitBGRA8881,
+    OMX_COLOR_Format24BitBGRA6666,
+    OMX_COLOR_Format24BitRGBA6666,
     OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_COLOR_FormatMax = 0x7FFFFFFF
 } OMX_COLOR_FORMATTYPE;
 
-
-/** 
- * Defines the matrix for conversion from RGB to YUV or vice versa.
- * iColorMatrix should be initialized with the fixed point values 
- * used in converting between formats.
- */
 typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
-    OMX_U32 nSize;              /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */ 
-    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
-    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
-    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 xColorMatrix[3][3];
+    OMX_S32 xColorOffset[4];
 }OMX_CONFIG_COLORCONVERSIONTYPE;
 
-
-/** 
- * Structure defining percent to scale each frame dimension.  For example:  
- * To make the width 50% larger, use fWidth = 1.5 and to make the width
- * 1/2 the original size, use fWidth = 0.5
- */
 typedef struct OMX_CONFIG_SCALEFACTORTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */ 
-    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
-    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
-    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 xWidth;
+    OMX_S32 xHeight;
 }OMX_CONFIG_SCALEFACTORTYPE;
 
-
-/** 
- * Enumeration of possible image filter types 
- */
 typedef enum OMX_IMAGEFILTERTYPE {
     OMX_ImageFilterNone,
     OMX_ImageFilterNoise,
@@ -179,21 +139,22 @@ typedef enum OMX_IMAGEFILTERTYPE {
     OMX_ImageFilterAntialias, 
     OMX_ImageFilterDeRing,       
     OMX_ImageFilterSolarize,
+    OMX_ImageFilterPastel,
+    OMX_ImageFilterMosaic,
+    OMX_ImageFilterPosterize,
+    OMX_ImageFilterWhiteboard,
+    OMX_ImageFilterBlackboard,
+    OMX_ImageFilterSepia,
+    OMX_ImageFilterGrayscale,
+    OMX_ImageFilterNatural,
+    OMX_ImageFilterVivid,
+    OMX_ImageFilterWaterColor,
+    OMX_ImageFilterFilm,
     OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_ImageFilterMax = 0x7FFFFFFF
 } OMX_IMAGEFILTERTYPE;
 
-
-/** 
- * Image filter configuration 
- *
- * STRUCT MEMBERS:
- *  nSize        : Size of the structure in bytes       
- *  nVersion     : OMX specification version information
- *  nPortIndex   : Port that this structure applies to 
- *  eImageFilter : Image filter type enumeration      
- */
 typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -201,20 +162,6 @@ typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
     OMX_IMAGEFILTERTYPE eImageFilter;
 } OMX_CONFIG_IMAGEFILTERTYPE;
 
-
-/** 
- * Customized U and V for color enhancement 
- *
- * STRUCT MEMBERS:
- *  nSize             : Size of the structure in bytes
- *  nVersion          : OMX specification version information 
- *  nPortIndex        : Port that this structure applies to
- *  bColorEnhancement : Enable/disable color enhancement
- *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for 
- *                      U component
- *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for 
- *                      V component
- */
 typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion; 
@@ -224,17 +171,6 @@ typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
     OMX_U8 nCustomizedV;
 } OMX_CONFIG_COLORENHANCEMENTTYPE;
 
-
-/** 
- * Define color key and color key mask 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
- *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
- */
 typedef struct OMX_CONFIG_COLORKEYTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -243,20 +179,6 @@ typedef struct OMX_CONFIG_COLORKEYTYPE {
     OMX_U32 nARGBMask;
 } OMX_CONFIG_COLORKEYTYPE;
 
-
-/** 
- * List of color blend types for pre/post processing 
- *
- * ENUMS:
- *  None          : No color blending present
- *  AlphaConstant : Function is (alpha_constant * src) + 
- *                  (1 - alpha_constant) * dst)
- *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
- *  Alternate     : Function is alternating pixels from src and dst
- *  And           : Function is (src & dst)
- *  Or            : Function is (src | dst)
- *  Invert        : Function is ~src
- */
 typedef enum OMX_COLORBLENDTYPE {
     OMX_ColorBlendNone,
     OMX_ColorBlendAlphaConstant,
@@ -270,17 +192,6 @@ typedef enum OMX_COLORBLENDTYPE {
     OMX_ColorBlendMax = 0x7FFFFFFF
 } OMX_COLORBLENDTYPE;
 
-
-/** 
- * Color blend configuration 
- *
- * STRUCT MEMBERS:
- *  nSize             : Size of the structure in bytes                        
- *  nVersion          : OMX specification version information                
- *  nPortIndex        : Port that this structure applies to                   
- *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
- *  eColorBlend       : Color blend type enumeration                         
- */
 typedef struct OMX_CONFIG_COLORBLENDTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -289,17 +200,6 @@ typedef struct OMX_CONFIG_COLORBLENDTYPE {
     OMX_COLORBLENDTYPE  eColorBlend;
 } OMX_CONFIG_COLORBLENDTYPE;
 
-
-/** 
- * Hold frame dimension
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes      
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to     
- *  nWidth     : Frame width in pixels                 
- *  nHeight    : Frame height in pixels                
- */
 typedef struct OMX_FRAMESIZETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -308,16 +208,6 @@ typedef struct OMX_FRAMESIZETYPE {
     OMX_U32 nHeight;
 } OMX_FRAMESIZETYPE;
 
-
-/**
- * Rotation configuration 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes             
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nRotation  : +/- integer rotation value               
- */
 typedef struct OMX_CONFIG_ROTATIONTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -325,16 +215,6 @@ typedef struct OMX_CONFIG_ROTATIONTYPE {
     OMX_S32 nRotation; 
 } OMX_CONFIG_ROTATIONTYPE;
 
-
-/** 
- * Possible mirroring directions for pre/post processing 
- *
- * ENUMS:
- *  None       : No mirroring                         
- *  Vertical   : Vertical mirroring, flip on X axis   
- *  Horizontal : Horizontal mirroring, flip on Y axis  
- *  Both       : Both vertical and horizontal mirroring
- */
 typedef enum OMX_MIRRORTYPE {
     OMX_MirrorNone = 0,
     OMX_MirrorVertical,
@@ -345,16 +225,6 @@ typedef enum OMX_MIRRORTYPE {
     OMX_MirrorMax = 0x7FFFFFFF   
 } OMX_MIRRORTYPE;
 
-
-/** 
- * Mirroring configuration 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes      
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to  
- *  eMirror    : Mirror type enumeration              
- */
 typedef struct OMX_CONFIG_MIRRORTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion; 
@@ -362,17 +232,6 @@ typedef struct OMX_CONFIG_MIRRORTYPE {
     OMX_MIRRORTYPE  eMirror;
 } OMX_CONFIG_MIRRORTYPE;
 
-
-/** 
- * Position information only 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes               
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nX         : X coordinate for the point                     
- *  nY         : Y coordinate for the point 
- */                      
 typedef struct OMX_CONFIG_POINTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -381,19 +240,6 @@ typedef struct OMX_CONFIG_POINTTYPE {
     OMX_S32 nY;
 } OMX_CONFIG_POINTTYPE;
 
-
-/** 
- * Frame size plus position 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes                    
- *  nVersion   : OMX specification version information      
- *  nPortIndex : Port that this structure applies to    
- *  nLeft      : X Coordinate of the top left corner of the rectangle
- *  nTop       : Y Coordinate of the top left corner of the rectangle
- *  nWidth     : Width of the rectangle                              
- *  nHeight    : Height of the rectangle                             
- */
 typedef struct OMX_CONFIG_RECTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;  
@@ -404,16 +250,6 @@ typedef struct OMX_CONFIG_RECTTYPE {
     OMX_U32 nHeight;
 } OMX_CONFIG_RECTTYPE;
 
-
-/** 
- * Deblocking state; it is required to be set up before starting the codec 
- *
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes      
- *  nVersion    : OMX specification version information 
- *  nPortIndex  : Port that this structure applies to
- *  bDeblocking : Enable/disable deblocking mode    
- */
 typedef struct OMX_PARAM_DEBLOCKINGTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -421,16 +257,6 @@ typedef struct OMX_PARAM_DEBLOCKINGTYPE {
     OMX_BOOL bDeblocking;
 } OMX_PARAM_DEBLOCKINGTYPE;
 
-
-/** 
- * Stabilization state 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes          
- *  nVersion   : OMX specification version information    
- *  nPortIndex : Port that this structure applies to   
- *  bStab      : Enable/disable frame stabilization state
- */
 typedef struct OMX_CONFIG_FRAMESTABTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -438,14 +264,6 @@ typedef struct OMX_CONFIG_FRAMESTABTYPE {
     OMX_BOOL bStab;
 } OMX_CONFIG_FRAMESTABTYPE;
 
-
-/** 
- * White Balance control type 
- *
- * STRUCT MEMBERS:
- *  SunLight : Referenced in JSR-234
- *  Flash    : Optimal for device's integrated flash
- */
 typedef enum OMX_WHITEBALCONTROLTYPE {
     OMX_WhiteBalControlOff = 0,
     OMX_WhiteBalControlAuto,
@@ -462,16 +280,6 @@ typedef enum OMX_WHITEBALCONTROLTYPE {
     OMX_WhiteBalControlMax = 0x7FFFFFFF
 } OMX_WHITEBALCONTROLTYPE;
 
-
-/** 
- * White Balance control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes       
- *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to                 
- *  eWhiteBalControl : White balance enumeration            
- */
 typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -479,10 +287,6 @@ typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
     OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
 } OMX_CONFIG_WHITEBALCONTROLTYPE;
 
-
-/** 
- * Exposure control type 
- */
 typedef enum OMX_EXPOSURECONTROLTYPE {
     OMX_ExposureControlOff = 0,
     OMX_ExposureControlAuto,
@@ -499,16 +303,6 @@ typedef enum OMX_EXPOSURECONTROLTYPE {
     OMX_ExposureControlMax = 0x7FFFFFFF
 } OMX_EXPOSURECONTROLTYPE;
 
-
-/** 
- * White Balance control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes      
- *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to                
- *  eExposureControl : Exposure control enumeration         
- */
 typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -516,18 +310,6 @@ typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
     OMX_EXPOSURECONTROLTYPE eExposureControl;
 } OMX_CONFIG_EXPOSURECONTROLTYPE;
 
-
-/** 
- * Defines sensor supported mode. 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes           
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to 
- *  nFrameRate : Single shot mode is indicated by a 0     
- *  bOneShot   : Enable for single shot, disable for streaming
- *  sFrameSize : Framesize                                          
- */
 typedef struct OMX_PARAM_SENSORMODETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -537,16 +319,6 @@ typedef struct OMX_PARAM_SENSORMODETYPE {
     OMX_FRAMESIZETYPE sFrameSize;
 } OMX_PARAM_SENSORMODETYPE;
 
-
-/** 
- * Defines contrast level 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes                              
- *  nVersion   : OMX specification version information                
- *  nPortIndex : Port that this structure applies to                 
- *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
- */
 typedef struct OMX_CONFIG_CONTRASTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -554,16 +326,6 @@ typedef struct OMX_CONFIG_CONTRASTTYPE {
     OMX_S32 nContrast;
 } OMX_CONFIG_CONTRASTTYPE;
 
-
-/** 
- * Defines brightness level 
- *
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes          
- *  nVersion    : OMX specification version information 
- *  nPortIndex  : Port that this structure applies to 
- *  nBrightness : 0-100%        
- */
 typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -571,18 +333,6 @@ typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
     OMX_U32 nBrightness;
 } OMX_CONFIG_BRIGHTNESSTYPE;
 
-
-/** 
- * Defines backlight level configuration for a video sink, e.g. LCD panel 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  nBacklight : Values allowed for backlight 0-100%
- *  nTimeout   : Number of milliseconds before backlight automatically turns 
- *               off.  A value of 0x0 disables backight timeout 
- */
 typedef struct OMX_CONFIG_BACKLIGHTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -591,16 +341,6 @@ typedef struct OMX_CONFIG_BACKLIGHTTYPE {
     OMX_U32 nTimeout;
 } OMX_CONFIG_BACKLIGHTTYPE;
 
-
-/** 
- * Defines setting for Gamma 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
- */
 typedef struct OMX_CONFIG_GAMMATYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -608,17 +348,6 @@ typedef struct OMX_CONFIG_GAMMATYPE {
     OMX_S32 nGamma;
 } OMX_CONFIG_GAMMATYPE;
 
-
-/** 
- * Define for setting saturation 
- * 
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes
- *  nVersion    : OMX specification version information
- *  nPortIndex  : Port that this structure applies to
- *  nSaturation : Values allowed for saturation -100 to 100, zero means 
- *                no change
- */
 typedef struct OMX_CONFIG_SATURATIONTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -626,17 +355,6 @@ typedef struct OMX_CONFIG_SATURATIONTYPE {
     OMX_S32 nSaturation;
 } OMX_CONFIG_SATURATIONTYPE;
 
-
-/** 
- * Define for setting Lightness 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nLightness : Values allowed for lightness -100 to 100, zero means no 
- *               change
- */
 typedef struct OMX_CONFIG_LIGHTNESSTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -644,20 +362,6 @@ typedef struct OMX_CONFIG_LIGHTNESSTYPE {
     OMX_S32 nLightness;
 } OMX_CONFIG_LIGHTNESSTYPE;
 
-
-/** 
- * Plane blend configuration 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes 
- *  nVersion   : OMX specification version information
- *  nPortIndex : Index of input port associated with the plane.
- *  nDepth     : Depth of the plane in relation to the screen. Higher 
- *               numbered depths are "behind" lower number depths.  
- *               This number defaults to the Port Index number.
- *  nAlpha     : Transparency blending component for the entire plane.  
- *               See blending modes for more detail.
- */
 typedef struct OMX_CONFIG_PLANEBLENDTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -666,20 +370,6 @@ typedef struct OMX_CONFIG_PLANEBLENDTYPE {
     OMX_U32 nAlpha;
 } OMX_CONFIG_PLANEBLENDTYPE;
 
-
-/** 
- * Define interlace type
- *
- * STRUCT MEMBERS:
- *  nSize                 : Size of the structure in bytes 
- *  nVersion              : OMX specification version information 
- *  nPortIndex            : Port that this structure applies to
- *  bEnable               : Enable control variable for this functionality 
- *                          (see below)
- *  nInterleavePortIndex  : Index of input or output port associated with  
- *                          the interleaved plane. 
- *  pPlanarPortIndexes[4] : Index of input or output planar ports.
- */
 typedef struct OMX_PARAM_INTERLEAVETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -688,10 +378,6 @@ typedef struct OMX_PARAM_INTERLEAVETYPE {
     OMX_U32 nInterleavePortIndex;
 } OMX_PARAM_INTERLEAVETYPE;
 
-
-/** 
- * Defines the picture effect used for an input picture 
- */
 typedef enum OMX_TRANSITIONEFFECTTYPE {
     OMX_EffectNone,
     OMX_EffectFadeFromBlack,
@@ -705,16 +391,6 @@ typedef enum OMX_TRANSITIONEFFECTTYPE {
     OMX_EffectMax = 0x7FFFFFFF
 } OMX_TRANSITIONEFFECTTYPE;
 
-
-/** 
- * Structure used to configure current transition effect 
- *
- * STRUCT MEMBERS:
- * nSize      : Size of the structure in bytes
- * nVersion   : OMX specification version information 
- * nPortIndex : Port that this structure applies to
- * eEffect    : Effect to enable
- */
 typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -722,12 +398,6 @@ typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
     OMX_TRANSITIONEFFECTTYPE eEffect;
 } OMX_CONFIG_TRANSITIONEFFECTTYPE;
 
-
-/** 
- * Defines possible data unit types for encoded video data. The data unit 
- * types are used both for encoded video input for playback as well as
- * encoded video output from recording. 
- */
 typedef enum OMX_DATAUNITTYPE {
     OMX_DataUnitCodedPicture,
     OMX_DataUnitVideoSegment,
@@ -738,12 +408,6 @@ typedef enum OMX_DATAUNITTYPE {
     OMX_DataUnitMax = 0x7FFFFFFF
 } OMX_DATAUNITTYPE;
 
-
-/** 
- * Defines possible encapsulation types for coded video data unit. The 
- * encapsulation information is used both for encoded video input for 
- * playback as well as encoded video output from recording. 
- */
 typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
     OMX_DataEncapsulationElementaryStream,
     OMX_DataEncapsulationGenericPayload,
@@ -753,22 +417,14 @@ typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
     OMX_DataEncapsulationMax = 0x7FFFFFFF
 } OMX_DATAUNITENCAPSULATIONTYPE;
 
-
-/** 
- * Structure used to configure the type of being decoded/encoded 
- */
 typedef struct OMX_PARAM_DATAUNITTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
     OMX_DATAUNITTYPE eUnitType;
     OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
 } OMX_PARAM_DATAUNITTYPE;
 
-
-/**
- * Defines dither types 
- */
 typedef enum OMX_DITHERTYPE {
     OMX_DitherNone,
     OMX_DitherOrdered,
@@ -779,38 +435,26 @@ typedef enum OMX_DITHERTYPE {
     OMX_DitherMax = 0x7FFFFFFF
 } OMX_DITHERTYPE;
 
-
-/** 
- * Structure used to configure current type of dithering 
- */
 typedef struct OMX_CONFIG_DITHERTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_DITHERTYPE eDither;
 } OMX_CONFIG_DITHERTYPE;
 
 typedef struct OMX_CONFIG_CAPTUREMODETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
-    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture 
-                             *   data as fast as possible (otherwise obey port's frame rate). */
-    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the 
-                             *   specified number of frames (otherwise the port does not 
-                             *   terminate the capture until instructed to do so by the client). 
-                             *   Even if set, the client may manually terminate the capture prior 
-                             *   to reaching the limit. */
-    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
-                               *   valid if bFrameLimited is set). */
+    OMX_U32 nPortIndex;
+    OMX_BOOL bContinuous;
+    OMX_BOOL bFrameLimited;
+    OMX_U32 nFrameLimit;
 } OMX_CONFIG_CAPTUREMODETYPE;
 
 typedef enum OMX_METERINGTYPE {
- 
-    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
-    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
-    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
- 
+    OMX_MeteringModeAverage,
+    OMX_MeteringModeSpot,
+    OMX_MeteringModeMatrix,
     OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_EVModeMax = 0x7fffffff
@@ -821,50 +465,15 @@ typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_METERINGTYPE eMetering;
-    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
-    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
-    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
-    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */ 
-    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */ 
-    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
-    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
+    OMX_S32 xEVCompensation;
+    OMX_U32 nApertureFNumber;
+    OMX_BOOL bAutoAperture;
+    OMX_U32 nShutterSpeedMsec;
+    OMX_BOOL bAutoShutterSpeed;
+    OMX_U32 nSensitivity;
+    OMX_BOOL bAutoSensitivity;
 } OMX_CONFIG_EXPOSUREVALUETYPE;
 
-/** 
- * Focus region configuration 
- *
- * STRUCT MEMBERS:
- *  nSize           : Size of the structure in bytes
- *  nVersion        : OMX specification version information
- *  nPortIndex      : Port that this structure applies to
- *  bCenter         : Use center region as focus region of interest
- *  bLeft           : Use left region as focus region of interest
- *  bRight          : Use right region as focus region of interest
- *  bTop            : Use top region as focus region of interest
- *  bBottom         : Use bottom region as focus region of interest
- *  bTopLeft        : Use top left region as focus region of interest
- *  bTopRight       : Use top right region as focus region of interest
- *  bBottomLeft     : Use bottom left region as focus region of interest
- *  bBottomRight    : Use bottom right region as focus region of interest
- */
-typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bCenter;
-    OMX_BOOL bLeft;
-    OMX_BOOL bRight;
-    OMX_BOOL bTop;
-    OMX_BOOL bBottom;
-    OMX_BOOL bTopLeft;
-    OMX_BOOL bTopRight;
-    OMX_BOOL bBottomLeft;
-    OMX_BOOL bBottomRight;
-} OMX_CONFIG_FOCUSREGIONTYPE;
-
-/** 
- * Focus Status type 
- */
 typedef enum OMX_FOCUSSTATUSTYPE {
     OMX_FocusStatusOff = 0,
     OMX_FocusStatusRequest,
@@ -876,41 +485,191 @@ typedef enum OMX_FOCUSSTATUSTYPE {
     OMX_FocusStatusMax = 0x7FFFFFFF
 } OMX_FOCUSSTATUSTYPE;
 
-/** 
- * Focus status configuration 
- *
- * STRUCT MEMBERS:
- *  nSize               : Size of the structure in bytes
- *  nVersion            : OMX specification version information
- *  nPortIndex          : Port that this structure applies to
- *  eFocusStatus        : Specifies the focus status
- *  bCenterStatus       : Use center region as focus region of interest
- *  bLeftStatus         : Use left region as focus region of interest
- *  bRightStatus        : Use right region as focus region of interest
- *  bTopStatus          : Use top region as focus region of interest
- *  bBottomStatus       : Use bottom region as focus region of interest
- *  bTopLeftStatus      : Use top left region as focus region of interest
- *  bTopRightStatus     : Use top right region as focus region of interest
- *  bBottomLeftStatus   : Use bottom left region as focus region of interest
- *  bBottomRightStatus  : Use bottom right region as focus region of interest
- */
-typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
+typedef struct OMX_SHARPNESSTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nSharpness;
+} OMX_SHARPNESSTYPE;
+
+typedef struct OMX_CONFIG_ZOOMFACTORTYPE { 
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex; 
+    OMX_BU32 xZoomFactor; 
+}OMX_CONFIG_ZOOMFACTORTYPE;
+
+typedef enum OMX_IMAGE_LOCKTYPE {
+    OMX_IMAGE_LockOff = 0, 
+    OMX_IMAGE_LockImmediate,
+    OMX_IMAGE_LockAtCapture,
+    OMX_IMAGE_LockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_LockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_LockMax = 0x7FFFFFFF
+} OMX_IMAGE_LOCKTYPE;
+
+typedef struct OMX_IMAGE_CONFIG_LOCKTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_LOCKTYPE eImageLock;
+} OMX_IMAGE_CONFIG_LOCKTYPE;
+
+typedef enum OMX_FOCUSRANGETYPE {
+    OMX_FocusRangeAuto = 0, 
+    OMX_FocusRangeHyperfocal,
+    OMX_FocusRangeNormal,
+    OMX_FocusRangeSuperMacro,
+    OMX_FocusRangeMacro,
+    OMX_FocusRangeInfinity,
+    OMX_FocusRangeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_FocusRangeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FocusRangeMax = 0x7FFFFFFF
+} OMX_FOCUSRANGETYPE;
+
+typedef struct OMX_CONFIG_FOCUSRANGETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_FOCUSRANGETYPE eFocusRange;
+} OMX_CONFIG_FOCUSRANGETYPE;
+
+typedef enum OMX_IMAGE_FLASHSTATUSTYPE
+{
+    OMX_IMAGE_FlashUnknown  = 0,
+    OMX_IMAGE_FlashOff,
+    OMX_IMAGE_FlashCharging,
+    OMX_IMAGE_FlashReady,
+    OMX_IMAGE_FlashNotAvailable,
+    OMX_IMAGE_FlashInsufficientCharge,
+    OMX_IMAGE_FlashKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FlashVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FlashMax = 0x7FFFFFFF
+} OMX_IMAGE_FLASHSTATUSTYPE;
+              
+typedef struct OMX_IMAGE_CONFIG_FLASHSTATUSTYPE { 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_IMAGE_FLASHSTATUSTYPE eFlashStatus;
+} OMX_IMAGE_CONFIG_FLASHSTATUSTYPE;
+
+typedef struct OMX_CONFIG_EXTCAPTUREMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nFrameBefore;
+    OMX_BOOL bPrepareCapture;
+} OMX_CONFIG_EXTCAPTUREMODETYPE;
+
+typedef enum OMX_NDFILTERCONTROLTYPE{
+    OMX_NDFilterOff,
+    OMX_NDFilterOn,
+    OMX_NDFilterAuto,
+    OMX_NDFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_NDFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_NDFilterMax = 0x7FFFFFFF
+} OMX_NDFILTERCONTROLTYPE;
+
+typedef struct OMX_CONFIG_NDFILTERCONTROLTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_NDFILTERCONTROLTYPE eNDFilterControl;
+} OMX_CONFIG_NDFILTERCONTROLTYPE;
+
+typedef enum OMX_AFASSISTANTLIGHTTYPE{
+    OMX_AFAssistantLightOff,
+    OMX_AFAssistantLightOn,
+    OMX_AFAssistantLightAuto,
+    OMX_AFAssistantLightKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AFAssistantLightVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AFAssistantLightMax = 0x7FFFFFFF
+} OMX_AFASSISTANTLIGHTTYPE;
+
+typedef struct OMX_CONFIG_AFASSISTANTLIGHTTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_AFASSISTANTLIGHTTYPE eAFAssistantLight;
+} OMX_CONFIG_AFASSISTANTLIGHTTYPE;
+
+#define OMX_InterlaceFrameProgressive                   0x00000001
+#define OMX_InterlaceInterleaveFrameTopFieldFirst       0x00000002
+#define OMX_InterlaceInterleaveFrameBottomFieldFirst    0x00000004
+#define OMX_InterlaceFrameTopFieldFirst                 0x00000008
+#define OMX_InterlaceFrameBottomFieldFirst              0x00000010
+#define OMX_InterlaceInterleaveFieldTop                 0x00000020
+#define OMX_InterlaceInterleaveFieldBottom              0x00000040
+
+typedef struct OMX_INTERLACEFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex; 
+    OMX_U32 nFormat;
+    OMX_TICKS nTimeStamp;
+#ifdef OMX_ADDITIONAL_INTERLACE_INFO
+    OMX_U32 nRepeatFirstField;         // IMG Vendor Specific.
+    OMX_BOOL bMbaffFrameFlag;
+#endif
+} OMX_INTERLACEFORMATTYPE;
+
+typedef struct  OMX_DEINTERLACETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+} OMX_DEINTERLACETYPE;
+
+typedef struct  OMX_STREAMINTERLACEFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bInterlaceFormat;
+    OMX_U32 nInterlaceFormats;
+} OMX_STREAMINTERLACEFORMAT;
+
+typedef struct OMX_FROITYPE {
+    OMX_S32 nRectX;
+    OMX_S32 nRectY;
+    OMX_S32 nRectWidth;
+    OMX_S32 nRectHeight;
+    OMX_S32 xFocusDistance;
     OMX_FOCUSSTATUSTYPE eFocusStatus;
-    OMX_BOOL bCenterStatus;
-    OMX_BOOL bLeftStatus;
-    OMX_BOOL bRightStatus;
-    OMX_BOOL bTopStatus;
-    OMX_BOOL bBottomStatus;
-    OMX_BOOL bTopLeftStatus;
-    OMX_BOOL bTopRightStatus;
-    OMX_BOOL bBottomLeftStatus;
-    OMX_BOOL bBottomRightStatus;
-} OMX_PARAM_FOCUSSTATUSTYPE;
-
-/** @} */
+} OMX_FROITYPE;
+
+typedef struct OMX_CONFIG_FOCUSREGIONSTATUSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bFocused;
+    OMX_U32 nMaxFAreas;
+    OMX_U32 nFAreas;
+    OMX_FROITYPE sFROIs[1];
+} OMX_CONFIG_FOCUSREGIONSTATUSTYPE;
+
+typedef enum OMX_FOCUSREGIONCONTROLTYPE {
+    OMX_FocusRegionControlAuto = 0,
+    OMX_FocusRegionControlManual,
+    OMX_FocusRegionControlFacePriority,
+    OMX_FocusRegionControlObjectPriority,
+    OMX_FocusRegionControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_FocusRegionControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FocusRegionControlMax = 0x7FFFFFFF
+} OMX_FOCUSREGIONCONTROLTYPE;
+
+typedef struct OMX_MANUALFOCUSRECTTYPE {
+    OMX_S32 nRectX;
+    OMX_S32 nRectY;
+    OMX_S32 nRectWidth;
+    OMX_S32 nRectHeight;
+} OMX_MANUALFOCUSRECTTYPE;
+
+typedef struct OMX_CONFIG_FOCUSREGIONCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nFAreas;
+    OMX_FOCUSREGIONCONTROLTYPE eFocusRegionsControl;
+    OMX_MANUALFOCUSRECTTYPE sManualFRegions[1];
+} OMX_CONFIG_FOCUSREGIONCONTROLTYPE;
+
+
 
 #ifdef __cplusplus
 }
diff --git a/omx/openmax/OMX_Image.h b/omx/openmax/OMX_Image.h
index a6d4666..6a0be96 100644
--- a/omx/openmax/OMX_Image.h
+++ b/omx/openmax/OMX_Image.h
@@ -1,5 +1,5 @@
-/**
- * Copyright (c) 2008 The Khronos Group Inc. 
+/*
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -17,14 +17,16 @@
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
  */
 
-/** 
- * @file OMX_Image.h - OpenMax IL version 1.1.2
+/* 
+ * OMX_Image.h - OpenMax IL version 1.2.0
  * The structures needed by Image components to exchange parameters and 
  * configuration data with the components.
  */
+
 #ifndef OMX_Image_h
 #define OMX_Image_h
 
@@ -41,75 +43,24 @@ extern "C" {
 
 #include <OMX_IVCommon.h>
 
-/** @defgroup imaging OpenMAX IL Imaging Domain
- * @ingroup iv
- * Structures for OpenMAX IL Imaging domain
- * @{
- */
-
-/** 
- * Enumeration used to define the possible image compression coding. 
- */
 typedef enum OMX_IMAGE_CODINGTYPE {
-    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
-    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
-    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
-    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
-    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
-    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
-    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
-    OMX_IMAGE_CodingPNG,         /**< PNG image format */
-    OMX_IMAGE_CodingLZW,         /**< LZW image format */
-    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
+    OMX_IMAGE_CodingUnused,
+    OMX_IMAGE_CodingAutoDetect,
+    OMX_IMAGE_CodingJPEG,
+    OMX_IMAGE_CodingJPEG2K,
+    OMX_IMAGE_CodingEXIF,
+    OMX_IMAGE_CodingTIFF,
+    OMX_IMAGE_CodingGIF,
+    OMX_IMAGE_CodingPNG,
+    OMX_IMAGE_CodingLZW,
+    OMX_IMAGE_CodingBMP,
+    OMX_IMAGE_CodingWEBP,
     OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_IMAGE_CodingMax = 0x7FFFFFFF
 } OMX_IMAGE_CODINGTYPE;
 
-
-/**
- * Data structure used to define an image path. The number of image paths 
- * for input and output will vary by type of the image component.  
- * 
- *  Input (aka Source) : Zero Inputs, one Output,
- *  Splitter           : One Input, 2 or more Outputs,
- *  Processing Element : One Input, one output,
- *  Mixer              : 2 or more inputs, one output,
- *  Output (aka Sink)  : One Input, zero outputs.
- * 
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output  
- * image path.  If additional vendor specific data is required, it should  
- * be transmitted to the component using the CustomCommand function.   
- * Compliant components will prepopulate this structure with optimal  
- * values during the OMX_GetParameter() command.
- *
- * STRUCT MEMBERS:
- *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a 
- *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on port if 
- *                          uncompressed format is used.  Use 0 for 
- *                          unknown, don't care or variable
- *  nFrameHeight          : Height of frame to be used on port if 
- *                          uncompressed format is used. Use 0 for 
- *                          unknown, don't care or variable
- *  nStride               : Number of bytes per span of an image (i.e. 
- *                          indicates the number of bytes to get from
- *                          span N to span N+1, where negative stride 
- *                          indicates the image is bottom up
- *  nSliceHeight          : Height used when encoding in slices
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
- *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of  
- *                          the component. When OMX_IMAGE_CodingUnused is 
- *                          specified, eColorFormat is valid
- *  eColorFormat          : Decompressed format used by this component
- *  pNativeWindow         : Platform specific reference for a window object if a 
- *                          display sink , otherwise this field is 0x0. 
- */
 typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;
     OMX_NATIVE_DEVICETYPE pNativeRender;
     OMX_U32 nFrameWidth; 
     OMX_U32 nFrameHeight;
@@ -121,22 +72,6 @@ typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
     OMX_NATIVE_WINDOWTYPE pNativeWindow;
 } OMX_IMAGE_PORTDEFINITIONTYPE;
 
-
-/**  
- * Port format parameter.  This structure is used to enumerate the various 
- * data input/output format supported by the port.
- * 
- * STRUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information
- *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from 
- *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the 
- *                       component. When OMX_IMAGE_CodingUnused is specified, 
- *                       eColorFormat is valid
- *  eColorFormat       : Decompressed format used by this component
- */
 typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -146,13 +81,6 @@ typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
     OMX_COLOR_FORMATTYPE eColorFormat;
 } OMX_IMAGE_PARAM_PORTFORMATTYPE;
 
-
-/** 
- * Flash control type 
- *
- * ENUMS
- *  Torch : Flash forced constantly on
- */
 typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
     OMX_IMAGE_FlashControlOn = 0,
     OMX_IMAGE_FlashControlOff,
@@ -165,16 +93,6 @@ typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
     OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
 } OMX_IMAGE_FLASHCONTROLTYPE;
 
-
-/** 
- * Flash control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize         : Size of the structure in bytes
- *  nVersion      : OMX specification version information
- *  nPortIndex    : Port that this structure applies to
- *  eFlashControl : Flash control type
- */
 typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -182,10 +100,6 @@ typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
     OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
 } OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
 
-
-/** 
- * Focus control type 
- */
 typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
     OMX_IMAGE_FocusControlOn = 0,
     OMX_IMAGE_FocusControlOff,
@@ -196,19 +110,6 @@ typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
     OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
 } OMX_IMAGE_FOCUSCONTROLTYPE;
 
- 
-/** 
- * Focus control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize           : Size of the structure in bytes
- *  nVersion        : OMX specification version information
- *  nPortIndex      : Port that this structure applies to
- *  eFocusControl   : Focus control
- *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
- *                    Interest is only in number of steps over this range.
- *  nFocusStepIndex : Current focus step index
- */
 typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -218,22 +119,6 @@ typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
     OMX_U32 nFocusStepIndex;
 } OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
 
-
-/** 
- * Q Factor for JPEG compression, which controls the tradeoff between image
- * quality and size.  Q Factor provides a more simple means of controlling
- * JPEG compression quality, without directly programming Quantization
- * tables for chroma and luma 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes         
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to 
- *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
- *               produces the smallest, worst quality images, and a factor 
- *               of 100 produces the largest, best quality images.  A 
- *               typical default is 75 for small good quality images               
- */
 typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
     OMX_U32 nSize;            
     OMX_VERSIONTYPE nVersion; 
@@ -241,10 +126,6 @@ typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
     OMX_U32 nQFactor;                                        
 } OMX_IMAGE_PARAM_QFACTORTYPE;
 
-/** 
- * Quantization table type 
- */
-
 typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
     OMX_IMAGE_QuantizationTableLuma = 0,
     OMX_IMAGE_QuantizationTableChroma,
@@ -255,23 +136,6 @@ typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
     OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
 } OMX_IMAGE_QUANTIZATIONTABLETYPE;
 
-/** 
- * JPEG quantization tables are used to determine DCT compression for
- * YUV data, as an alternative to specifying Q factor, providing exact 
- * control of compression 
- *
- * STRUCT MEMBERS:
- *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information 
- *  nPortIndex              : Port that this structure applies to
- *  eQuantizationTable      : Quantization table type
- *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
- *                            in increasing columns then by rows of data (i.e. 
- *                            row 1, ... row 8). Quantization values are in 
- *                            the range 0-255 and stored in linear order
- *                            (i.e. the component will zig-zag the 
- *                            quantization table data if required internally) 
- */
 typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -280,11 +144,6 @@ typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
     OMX_U8 nQuantizationMatrix[64];
 } OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
 
-
-/** 
- * Huffman table type, the same Huffman table is applied for chroma and 
- * luma component 
- */
 typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
     OMX_IMAGE_HuffmanTableAC = 0,
     OMX_IMAGE_HuffmanTableDC,
@@ -297,19 +156,6 @@ typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
     OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
 } OMX_IMAGE_HUFFMANTABLETYPE;
 
-/** 
- * JPEG Huffman table 
- *
- * STRUCT MEMBERS:
- *  nSize                            : Size of the structure in bytes
- *  nVersion                         : OMX specification version information
- *  nPortIndex                       : Port that this structure applies to
- *  eHuffmanTable                    : Huffman table type
- *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
- *                                     possible length
- *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
- *                                     HuffmanTable are 16 and 162 
- */
 typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -319,7 +165,59 @@ typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
     OMX_U8 nHuffmanTable[256];
 }OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
 
-/** @} */
+typedef enum OMX_FLICKERREJECTIONTYPE {
+    OMX_FlickerRejectionOff = 0,
+    OMX_FlickerRejectionAuto,
+    OMX_FlickerRejection50,
+    OMX_FlickerRejection60,
+    OMX_FlickerRejectionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_FlickerRejectionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FlickerRejectionMax = 0x7FFFFFFF
+}OMX_FLICKERREJECTIONTYPE;
+
+typedef struct OMX_CONFIG_FLICKERREJECTIONTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_FLICKERREJECTIONTYPE eFlickerRejection;
+} OMX_CONFIG_FLICKERREJECTIONTYPE;
+
+typedef enum OMX_HISTOGRAMTYPE {
+    OMX_Histogram_Off = 0,
+    OMX_Histogram_RGB,
+    OMX_Histogram_Luma,
+    OMX_Histogram_Chroma,
+    OMX_HistogramKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_HistogramVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_HistogramMax = 0x7FFFFFFF
+}OMX_HISTOGRAMTYPE;
+
+typedef struct OMX_IMAGE_HISTOGRAMTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBins;
+    OMX_HISTOGRAMTYPE eHistType;
+} OMX_IMAGE_HISTOGRAMTYPE;
+
+typedef struct OMX_IMAGE_HISTOGRAMDATATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_HISTOGRAMTYPE eHistType;
+    OMX_U32 nBins;
+    OMX_U8 data[1];
+} OMX_IMAGE_HISTOGRAMDATATYPE;
+
+typedef struct OMX_IMAGE_HISTOGRAMINFOTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_HISTOGRAMTYPE eHistType;
+    OMX_U32 nBins;
+    OMX_U16 nBitsPerBin;
+} OMX_IMAGE_HISTOGRAMINFOTYPE;
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/omx/openmax/OMX_Index.h b/omx/openmax/OMX_Index.h
index 44d4ea7..e9c79c9 100644
--- a/omx/openmax/OMX_Index.h
+++ b/omx/openmax/OMX_Index.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,12 +21,12 @@
  *
  */
 
-/** @file OMX_Index.h - OpenMax IL version 1.1.2
+/*
+ *  OMX_Index.h - OpenMax IL version 1.2.0
  *  The OMX_Index header file contains the definitions for both applications
  *  and components .
  */
 
-
 #ifndef OMX_Index_h
 #define OMX_Index_h
 
@@ -41,22 +41,6 @@ extern "C" {
  */
 #include <OMX_Types.h>
 
-
-/** The OMX_INDEXTYPE enumeration is used to select a structure when either
- *  getting or setting parameters and/or configuration data.  Each entry in 
- *  this enumeration maps to an OMX specified structure.  When the 
- *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
- *  are used, the second parameter will always be an entry from this enumeration
- *  and the third entry will be the structure shown in the comments for the entry.
- *  For example, if the application is initializing a cropping function, the 
- *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter 
- *  and would send a pointer to an initialized OMX_RECTTYPE structure as the 
- *  third parameter.
- *  
- *  The enumeration entries named with the OMX_Config prefix are sent using
- *  the OMX_SetConfig command and the enumeration entries named with the
- *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
- */
 typedef enum OMX_INDEXTYPE {
 
     OMX_IndexComponentStartUnused = 0x01000000,
@@ -73,7 +57,7 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */ 
     OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
     OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
-    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */ 
+    OMX_IndexReserved_0x0100000E,           /**< reference: OMX_PARAM_CONTENTPIPETYPE deprecated*/ 
     OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
     OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
     OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
@@ -83,6 +67,9 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
     OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
     OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */
+    OMX_IndexConfigContentURI,              /**< reference: OMX_PARAM_CONTENTURITYPE */
+    OMX_IndexConfigCommonPortCapturing,     /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */ 
+    OMX_IndexConfigTunneledPortStatus,      /**< reference: OMX_CONFIG_TUNNELEDPORTSTATUSTYPE */
 
     OMX_IndexPortStartUnused = 0x02000000,
     OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
@@ -139,6 +126,22 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
     OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
     OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
+    OMX_IndexConfigAudio3DOutput,           /**< reference: OMX_AUDIO_CONFIG_3DOUTPUTTYPE */
+    OMX_IndexConfigAudio3DLocation,         /**< reference: OMX_AUDIO_CONFIG_3DLOCATIONTYPE */
+    OMX_IndexParamAudio3DDopplerMode,       /**< reference: OMX_AUDIO_PARAM_3DDOPPLERMODETYPE */
+    OMX_IndexConfigAudio3DDopplerSettings,  /**< reference: OMX_AUDIO_CONFIG_3DDOPPLERSETTINGSTYPE */
+    OMX_IndexConfigAudio3DLevels,           /**< reference: OMX_AUDIO_CONFIG_3DLEVELSTYPE */
+    OMX_IndexConfigAudio3DDistanceAttenuation,    /**< reference: OMX_AUDIO_CONFIG_3DDISTANCEATTENUATIONTYPE */
+    OMX_IndexConfigAudio3DDirectivitySettings,    /**< reference: OMX_AUDIO_CONFIG_3DDIRECTIVITYSETTINGSTYPE */
+    OMX_IndexConfigAudio3DDirectivityOrientation, /**< reference: OMX_AUDIO_CONFIG_3DDIRECTIVITYORIENTATIONTYPE */
+    OMX_IndexConfigAudio3DMacroscopicOrientation, /**< reference: OMX_AUDIO_CONFIG_3DMACROSCOPICORIENTATIONTYPE */
+    OMX_IndexConfigAudio3DMacroscopicSize,  /**< reference: OMX_AUDIO_CONFIG_3DMACROSCOPICSIZETYPE */
+    OMX_IndexParamAudioQueryChannelMapping, /**< reference: OMX_AUDIO_CHANNELMAPPINGTYPE */
+    OMX_IndexConfigAudioSbcBitpool,         /**< reference: OMX_AUDIO_SBCBITPOOLTYPE */
+    OMX_IndexConfigAudioAmrMode,            /**< reference: OMX_AUDIO_AMRMODETYPE */
+    OMX_IndexConfigAudioBitrate,            /**< reference: OMX_AUDIO_CONFIG_BITRATETYPE */
+    OMX_IndexConfigAudioAMRISFIndex,        /**< reference: OMX_AUDIO_CONFIG_AMRISFTYPE */
+    OMX_IndexParamAudioFixedPoint,          /**< reference: OMX_AUDIO_FIXEDPOINTTYPE */
 
     /* Image specific parameters and configurations */
     OMX_IndexImageStartUnused = 0x05000000,
@@ -149,6 +152,12 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
     OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
     OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+    OMX_IndexConfigFlickerRejection,        /**< reference: OMX_CONFIG_FLICKERREJECTIONTYPE */
+    OMX_IndexConfigImageHistogram,          /**< reference: OMX_IMAGE_HISTOGRAMTYPE */
+    OMX_IndexConfigImageHistogramData,      /**< reference: OMX_IMAGE_HISTOGRAMDATATYPE */
+    OMX_IndexConfigImageHistogramInfo,      /**< reference: OMX_IMAGE_HISTOGRAMINFOTYPE */
+    OMX_IndexConfigImageCaptureStarted,     /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexConfigImageCaptureEnded,       /**< reference: OMX_PARAM_U32TYPE */
 
     /* Video specific parameters and configurations */
     OMX_IndexVideoStartUnused = 0x06000000,
@@ -178,6 +187,15 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
     OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
     OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
+    OMX_IndexParamNalStreamFormatSupported, /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormat,          /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormatSelect,    /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamVideoVC1,                 /**< reference: OMX_VIDEO_PARAM_VC1TYPE */
+    OMX_IndexConfigVideoIntraPeriod,        /**< reference: OMX_VIDEO_INTRAPERIODTYPE */
+    OMX_IndexConfigVideoIntraRefresh,       /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
+    OMX_IndexParamVideoVp8,                 /**< reference: OMX_VIDEO_PARAM_VP8TYPE */
+    OMX_IndexConfigVideoVp8ReferenceFrame,  /**< reference: OMX_VIDEO_VP8REFERENCEFREAMETYPE */
+    OMX_IndexConfigVideoVp8ReferenceFrameType,  /**< reference: OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE */
 
     /* Image & Video common Configurations */
     OMX_IndexCommonStartUnused = 0x07000000,
@@ -212,9 +230,26 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
     OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
     OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
-    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
-    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
+    OMX_IndexReserved_0x0700002A,           /**< reference: OMX_CONFIG_FOCUSREGIONTYPE deprecated */
+    OMX_IndexReserved_0x0700002B,           /**< reference: OMX_PARAM_FOCUSSTATUSTYPE deprecated */
     OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */
+    OMX_IndexConfigSharpness,               /**< reference: OMX_SHARPNESSTYPE */
+    OMX_IndexConfigCommonExtDigitalZoom,    /**< reference: OMX_CONFIG_ZOOMFACTORTYPE */
+    OMX_IndexConfigCommonExtOpticalZoom,    /**< reference: OMX_CONFIG_ZOOMFACTORTYPE */
+    OMX_IndexConfigCommonCenterFieldOfView, /**< reference: OMX_CONFIG_POINTTYPE */
+    OMX_IndexConfigImageExposureLock,       /**< reference: OMX_IMAGE_CONFIG_LOCKTYPE */
+    OMX_IndexConfigImageWhiteBalanceLock,   /**< reference: OMX_IMAGE_CONFIG_LOCKTYPE */
+    OMX_IndexConfigImageFocusLock,          /**< reference: OMX_IMAGE_CONFIG_LOCKTYPE */
+    OMX_IndexConfigCommonFocusRange,        /**< reference: OMX_CONFIG_FOCUSRANGETYPE */
+    OMX_IndexConfigImageFlashStatus,        /**< reference: OMX_FLASHSTATUSTYPE */
+    OMX_IndexConfigCommonExtCaptureMode,    /**< reference: OMX_CONFIG_EXTCAPTUREMODETYPE */
+    OMX_IndexConfigCommonNDFilterControl,   /**< reference: OMX_CONFIG_NDFILTERCONTROLTYPE */
+    OMX_IndexConfigCommonAFAssistantLight,  /**< reference: OMX_CONFIG_AFASSISTANTLIGHTTYPE */
+    OMX_IndexConfigCommonFocusRegionStatus, /**< reference: OMX_CONFIG_FOCUSREGIONSTATUSTYPE */
+    OMX_IndexConfigCommonFocusRegionControl,/**< reference: OMX_CONFIG_FOCUSREGIONCONTROLTYPE */
+    OMX_IndexParamInterlaceFormat,          /**< reference: OMX_INTERLACEFORMATTYPE */
+    OMX_IndexConfigDeInterlace,             /**< reference: OMX_DEINTERLACETYPE */
+    OMX_IndexConfigStreamInterlaceFormats,  /**< reference: OMX_STREAMINTERLACEFORMATTYPE */
 
     /* Reserved Configuration range */
     OMX_IndexOtherStartUnused = 0x08000000,
@@ -222,30 +257,56 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
     OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */
 
-
     /* Reserved Time range */
     OMX_IndexTimeStartUnused = 0x09000000,
     OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
     OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
-    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
-    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
-    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
-    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
-    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexReserved_0x90000003,           /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE decrepcated */
+    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    OMX_IndexReserved_0x09000006,           /**< OMX_IndexConfigTimeCurrentAudioReference deprecated */
+    OMX_IndexReserved_0x09000007,           /**< reference: OMX_IndexConfigTimeCurrentVideoReference deprecated */
+    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE */
+    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE */
     OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
     OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
+    OMX_IndexConfigTimeCurrentReference,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    OMX_IndexConfigTimeActiveRefClockUpdate,/**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKUPDATETYPE*/
+    OMX_IndexConfigTimeRenderingDelay,      /**< reference: OMX_TIME_CONFIG_RENDERINGDELAYTYPE */
+    OMX_IndexConfigTimeUpdate,              /**< reference: OMX_TIME_MEDIATIMETYPE */
 
+    /* Common or Domain Independent Time range */
+    OMX_IndexCommonIndependentStartUnused = 0x0A000000,
+    OMX_IndexConfigCommitMode,              /**< reference: OMX_CONFIG_COMMITMODETYPE */
+    OMX_IndexConfigCommit,                  /**< reference: OMX_CONFIG_COMMITTYPE */
+    OMX_IndexConfigCallbackRequest,         /**< reference: OMX_CONFIG_CALLBACKREQUESTTYPE */
+    OMX_IndexParamMediaContainer,           /**< reference: OMX_MEDIACONTAINER_INFOTYPE */
+    OMX_IndexParamReadOnlyBuffers,          /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */ 
 
     OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     /* Vendor specific area */
-    OMX_IndexVendorStartUnused = 0x7F000000,
+    OMX_IndexVendorStartUnused = 0x7F000000, 
     /* Vendor specific structures should be in the range of 0x7F000000 
        to 0x7FFFFFFE.  This range is not broken out by vendor, so
        private indexes are not guaranteed unique and therefore should
        only be sent to the appropriate component. */
+#ifdef HAS_GSTREAMER
+    OMX_IndexImgElementary, /**<  Data "could" come with start codes. Stream Header is inband */ 
+    OMX_IndexImgParsed,     /**<  Data arrives in logical units, like frameboundary or NAL units. Stream Header is out-of-band*/
+    OMX_IndexImgAVCDataIsNALSizeDelimited, /**< Data arrives in logical units in frame boundary with NAL size delimited*/ 
+#endif
 
+#ifdef ANDROID
+    OMX_IndexImgEnableAndroidNativeBuffers,         /**< Corresponds to Stagefright's 'OMX.google.android.index.enableAndroidNativeBuffers' Index */
+    OMX_IndexImgUseAndroidNativeBuffers,            /**< Corresponds to Stagefright's 'OMX.google.android.index.useAndroidNativeBuffer' Index */
+	OMX_IndexImgUseAndroidNativeBuffers2,
+    OMX_IndexImgGetAndroidNativeBufferUsageParams,  /**< Corresponds to Stagefright's 'OMX.google.android.index.getAndroidNativeBufferUsage' Index */
+    OMX_IndexImgVideoDecoderOutputMetaData,             /**< Corresponds to Stagefright's 'OMX.google.android.index.storeMetaDataInBuffers' Index */
+    OMX_IndexImgConfigureHarwareFeatures,           /**< Configure the Hardware Specific Features */
+    OMX_IndexImgPrepareForAdaptivePlayback,         /**< Corresponds to Stagefright's 'OMX_IndexImgPrepareForAdaptivePlayback' index*/
+#endif
+    OMX_IndexImgEnableMultiViewDecoding = 0x7FFFFFFD, /*< Corresponds to MVC Decoding */
+    OMX_IndexImgAspectRatio = 0x7FFFFFFE,    /*Used with OMX_IMG_ASPECTRATIOTYPE to get Aspect Ratio info. Make sure that this is 0x7F000001 in any GST-headers*/
     OMX_IndexMax = 0x7FFFFFFF
 
 } OMX_INDEXTYPE;
diff --git a/omx/openmax/OMX_IndexExt.h b/omx/openmax/OMX_IndexExt.h
deleted file mode 100644
index 7a38175..0000000
--- a/omx/openmax/OMX_IndexExt.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** @file OMX_IndexExt.h - OpenMax IL version 1.1.2
- * The OMX_IndexExt header file contains extensions to the definitions 
- * for both applications and components .
- */
-
-#ifndef OMX_IndexExt_h
-#define OMX_IndexExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Index.h>
-
-
-/** Khronos standard extension indices.
-
-This enum lists the current Khronos extension indices to OpenMAX IL.
-*/
-typedef enum OMX_INDEXEXTTYPE {
-
-    /* Component parameters and configurations */
-    OMX_IndexExtComponentStartUnused = OMX_IndexKhronosExtensions + 0x00100000,
-    OMX_IndexConfigCallbackRequest,                 /**< reference: OMX_CONFIG_CALLBACKREQUESTTYPE */
-    OMX_IndexConfigCommitMode,                      /**< reference: OMX_CONFIG_COMMITMODETYPE */
-    OMX_IndexConfigCommit,                          /**< reference: OMX_CONFIG_COMMITTYPE */
-
-    /* Port parameters and configurations */
-    OMX_IndexExtPortStartUnused = OMX_IndexKhronosExtensions + 0x00200000,
-
-    /* Audio parameters and configurations */
-    OMX_IndexExtAudioStartUnused = OMX_IndexKhronosExtensions + 0x00400000,
-
-    /* Image parameters and configurations */
-    OMX_IndexExtImageStartUnused = OMX_IndexKhronosExtensions + 0x00500000,
-
-    /* Video parameters and configurations */
-    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
-    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
-    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
-    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */
-
-    /* Image & Video common configurations */
-    OMX_IndexExtCommonStartUnused = OMX_IndexKhronosExtensions + 0x00700000,
-
-    /* Following two Indexes are added by IMG to support Interlace format propagation
-       picked up from OMX 1.2 hdrs */
-    OMX_IndexParamInterlaceFormat = 0x7000031,          /**<reference: OMX_INTERLACEFORMATTYPE */
-    OMX_IndexConfigStreamInterlaceFormats = 0x7000033,  /**<reference: OMX_STREAMINTERLACEFORMATTYPE */
-	OMX_IndexImgAVCDataIsNALSizeDelimited = 0x7F000003, /**< Data arrives in logical units in frame boundary with NAL size delimited*/
-
-    /* Other configurations */
-    OMX_IndexExtOtherStartUnused = OMX_IndexKhronosExtensions + 0x00800000,
-
-    /* Time configurations */
-    OMX_IndexExtTimeStartUnused = OMX_IndexKhronosExtensions + 0x00900000,
-	OMX_IndexImgAspectRatio = 0x7FFFFFFE,    /*Used with OMX_IMG_ASPECTRATIOTYPE to get Aspect Ratio info*/
-    OMX_IndexExtMax = 0x7FFFFFFF
-} OMX_INDEXEXTTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_IndexExt_h */
-/* File EOF */
diff --git a/omx/openmax/OMX_Other.h b/omx/openmax/OMX_Other.h
index caf7f38..40461d5 100644
--- a/omx/openmax/OMX_Other.h
+++ b/omx/openmax/OMX_Other.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,7 +21,8 @@
  *
  */
 
-/** @file OMX_Other.h - OpenMax IL version 1.1.2
+/*
+ *  OMX_Other.h - OpenMax IL version 1.2.0
  *  The structures needed by Other components to exchange
  *  parameters and configuration data with the components.
  */
@@ -41,20 +42,11 @@ extern "C" {
 
 #include <OMX_Core.h>
 
-
-/** 
- * Enumeration of possible data types which match to multiple domains or no
- * domain at all.  For types which are vendor specific, a value above
- * OMX_OTHER_VENDORTSTART should be used.
- */
 typedef enum OMX_OTHER_FORMATTYPE {
-    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
-                                   time deltas, etc */
-    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
-                                   management, setting clocks? */
-    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
-                                   dropped, etc */
-    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
+    OMX_OTHER_FormatTime = 0,
+    OMX_OTHER_FormatPower,
+    OMX_OTHER_FormatStats,
+    OMX_OTHER_FormatBinary,
     OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
                                                 formats */
 
@@ -63,191 +55,81 @@ typedef enum OMX_OTHER_FORMATTYPE {
     OMX_OTHER_FormatMax = 0x7FFFFFFF
 } OMX_OTHER_FORMATTYPE;
 
-/** 
- * Enumeration of seek modes.
- */
 typedef enum OMX_TIME_SEEKMODETYPE {
-    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
-                                * of the requested seek position over   
-                                * the actual seek position if it
-                                * results in a faster seek. */
-    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
-                                * position over an approximation
-                                * of the requested seek position even
-                                * if it results in a slower seek. */
+    OMX_TIME_SeekModeFast = 0,
+    OMX_TIME_SeekModeAccurate,
     OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_TIME_SeekModeMax = 0x7FFFFFFF
 } OMX_TIME_SEEKMODETYPE;
 
-/* Structure representing the seekmode of the component */
 typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_TIME_SEEKMODETYPE eType;
 } OMX_TIME_CONFIG_SEEKMODETYPE;
 
-/** Structure representing a time stamp used with the following configs 
- * on the Clock Component (CC):
- * 
- * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall  
- *     time
- * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
- *     time
- * OMX_IndexConfigTimeCurrentAudioReference and  
- * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference 
- *     clock sending SC its reference time
- * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
- *     this structure to the Clock Component via a SetConfig on its 
- *     client port when it receives a buffer with
- *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
- *     specified by that buffer for nStartTimestamp. 
- *
- * Its also used with the following config on components in general:
- *
- * OMX_IndexConfigTimePosition: IL client querying component position 
- * (GetConfig) or commanding a component to seek to the given location
- * (SetConfig)
- */	
 typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
-    OMX_U32 nSize;               /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
-                                  *   information */
-    OMX_U32 nPortIndex;     /**< port that this structure applies to */
-    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_TICKS nTimestamp;
 } OMX_TIME_CONFIG_TIMESTAMPTYPE;  
 
-/** Enumeration of possible reference clocks to the media time. */
 typedef enum OMX_TIME_UPDATETYPE {
-      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
-      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
-      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
+      OMX_TIME_UpdateRequestFulfillment,
+      OMX_TIME_UpdateScaleChanged,
+      OMX_TIME_UpdateClockStateChanged,
       OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
       OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
       OMX_TIME_UpdateMax = 0x7FFFFFFF
 } OMX_TIME_UPDATETYPE;
 
-/** Enumeration of possible reference clocks to the media time. */
 typedef enum OMX_TIME_REFCLOCKTYPE {
-      OMX_TIME_RefClockNone,    /**< Use no references. */
-      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
-      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
+      OMX_TIME_RefClockNone,
+      OMX_TIME_RefClockAudio,
+      OMX_TIME_RefClockVideo,
       OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
       OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
       OMX_TIME_RefClockMax = 0x7FFFFFFF
 } OMX_TIME_REFCLOCKTYPE;
 
-/** Enumeration of clock states. */
 typedef enum OMX_TIME_CLOCKSTATE {
-      OMX_TIME_ClockStateRunning,             /**< Clock running. */
-      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
-                                               *   prescribed clients emit their
-                                               *   start time. */
-      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
+      OMX_TIME_ClockStateRunning,
+      OMX_TIME_ClockStateWaitingForStartTime,
+      OMX_TIME_ClockStateStopped,
       OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
       OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
       OMX_TIME_ClockStateMax = 0x7FFFFFFF
 } OMX_TIME_CLOCKSTATE;
 
-/** Structure representing a media time request to the clock component.
- *
- *  A client component sends this structure to the Clock Component via a SetConfig
- *  on its client port to specify a media timestamp the Clock Component
- *  should emit.  The Clock Component should fulfill the request by sending a
- *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
- *  timestamp.
- *
- *  The client may require a media time request be fulfilled slightly
- *  earlier than the media time specified. In this case the client specifies 
- *  an offset which is equal to the difference between wall time corresponding 
- *  to the requested media time and the wall time when it will be 
- *  fulfilled. 
- *
- *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
- *  time events according to timestamps. If a client must perform an operation O at
- *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
- *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
- *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
- *  structure back to the client component, the client may perform operation O (perhaps having
- *  to wait a slight amount more time itself as specified by the return values).
- */
-
 typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
-                                 *   from others (e.g. the number of the frame to deliver). 
-                                 *   Duplicated in the media time structure that fulfills 
-                                 *   this request. A value of zero is reserved for time scale 
-                                 *   updates. */
-    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
-    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
-                                 *   request should be fulfilled early */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_PTR pClientPrivate;
+    OMX_TICKS nMediaTimestamp;
+    OMX_TICKS nOffset;
 } OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
 
-/**< Structure sent from the clock component client either when fulfilling 
- *   a media time request or when the time scale has changed. 
- *
- *   In the former case the Clock Component fills this structure and times its emission 
- *   to a client component (via the client port) according to the corresponding media 
- *   time request sent by the client. The Clock Component should time the emission to occur
- *   when the requested timestamp matches the Clock Component's media time but also the 
- *   prescribed offset early. 
- *
- *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
- *   media time and sets the nScale to the new scale via the client port. It emits a 
- *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
- *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
- *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
- *   from an audio frame to scale audio data. 
- *
- *   It is expected that some clock components may not be able to fulfill requests
- *   at exactly the prescribed time. This is acceptable so long as the request is 
- *   fulfilled at least as early as described and not later. This structure provides 
- *   fields the client may use to wait for the remaining time.
- *
- *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
- *   wall time until the nMediaTimestamp actually occurs. In the latter case the
- *   client can get a more accurate value for offset by getting the current wall
- *   from the cloc component and subtracting it from nWallTimeAtMedia. 
- */
-
 typedef struct OMX_TIME_MEDIATIMETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
-                                     *   from others. Copied from the media time request. 
-                                     *   A value of zero is reserved for time scale updates. */
-    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
-    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
-                                     *   requested then this is the current media time. */ 
-    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
-                                     *   request was actually fulfilled early */
-
-    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
-                                     *   A client may compare this value to current
-                                     *   media time obtained from the Clock Component to determine
-                                     *   the wall time until the media timestamp is really
-                                     *   current. */
-    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
-    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
-                                    /**< State of the media time. */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nClientPrivate;
+    OMX_TIME_UPDATETYPE eUpdateType;
+    OMX_TICKS nMediaTimestamp;
+    OMX_TICKS nOffset;
+    OMX_TICKS nWallTimeAtMediaTime;
+    OMX_S32 xScale;
+    OMX_TIME_CLOCKSTATE eState;
 } OMX_TIME_MEDIATIMETYPE;  
 
-/** Structure representing the current media time scale factor. Applicable only to clock 
- *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
- *  the clock component client ports. Upon recieving this config the clock component changes 
- *  the rate by which the media time increases or decreases effectively implementing trick modes. 
- */ 
 typedef struct OMX_TIME_CONFIG_SCALETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
-                                     * scaling the media time */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_S32 xScale;
 } OMX_TIME_CONFIG_SCALETYPE;
  
-/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
 #define OMX_CLOCKPORT0 0x00000001
 #define OMX_CLOCKPORT1 0x00000002
 #define OMX_CLOCKPORT2 0x00000004
@@ -257,78 +139,53 @@ typedef struct OMX_TIME_CONFIG_SCALETYPE {
 #define OMX_CLOCKPORT6 0x00000040
 #define OMX_CLOCKPORT7 0x00000080
 
-/** Structure representing the current mode of the media clock. 
- *  IL Client uses this config to change or query the mode of the 
- *  media clock of the clock component. Applicable only to clock
- *  component. 
- *  
- *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
- *  starts immediately at the prescribed start time. If
- *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
- *  the given nStartTime and waits for all clients specified in the 
- *  nWaitMask to send starttimes (via 
- *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
- *  the media clock using the earliest start time supplied. */    
 typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
-                                 *   information */
-    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
-    OMX_TICKS nStartTime;       /**< Start time of the media time. */
-    OMX_TICKS nOffset;          /**< Time to offset the media time by 
-                                 * (e.g. preroll). Media time will be
-                                 * reported to be nOffset ticks earlier.     
-                                 */
-    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_TIME_CLOCKSTATE eState;
+    OMX_TICKS nStartTime;
+    OMX_TICKS nOffset;
+    OMX_U32 nWaitMask;
 } OMX_TIME_CONFIG_CLOCKSTATETYPE;
 
-/** Structure representing the reference clock currently being used to
- *  compute media time. IL client uses this config to change or query the 
- *  clock component's active reference clock */
-typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
-} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
-
-/** Descriptor for setting specifics of power type.
- *  Note: this structure is listed for backwards compatibility. */
 typedef struct OMX_OTHER_CONFIG_POWERTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bEnablePM;
 } OMX_OTHER_CONFIG_POWERTYPE;
 
-
-/** Descriptor for setting specifics of stats type.
- *  Note: this structure is listed for backwards compatibility. */
 typedef struct OMX_OTHER_CONFIG_STATSTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
     /* what goes here */
 } OMX_OTHER_CONFIG_STATSTYPE;
 
-
-/**
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output other 
- * path.
- */
 typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
-    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
+    OMX_OTHER_FORMATTYPE eFormat;
 } OMX_OTHER_PORTDEFINITIONTYPE;
 
-/**  Port format parameter.  This structure is used to enumerate
-  *  the various data input/output format supported by the port.
-  */
 typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize; /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex; /**< Indicates which port to set */
-    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
-    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_OTHER_FORMATTYPE eFormat;
 } OMX_OTHER_PARAM_PORTFORMATTYPE; 
 
+typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKUPDATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bEnableRefClockUpdates;
+    OMX_TICKS nRefTimeUpdateInterval;
+} OMX_TIME_CONFIG_ACTIVEREFCLOCKUPDATETYPE;
+
+typedef struct OMX_TIME_CONFIG_RENDERINGDELAYTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_TICKS nRenderingDelay;
+} OMX_TIME_CONFIG_RENDERINGDELAYTYPE;
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/omx/openmax/OMX_RoleNames.h b/omx/openmax/OMX_RoleNames.h
new file mode 100644
index 0000000..64f002c
--- /dev/null
+++ b/omx/openmax/OMX_RoleNames.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2011 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/*
+ *  OMX_RoleNames.h - OpenMax IL version 1.2.0
+ *  The OMX_RoleNames header file contains the standard role names as defined
+ *  strings.
+ */
+
+#ifndef OMX_RoleNames_h
+#define OMX_RoleNames_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Audio decoder class */
+#define OMX_ROLE_AUDIO_DECODER_AAC      "audio_decoder.aac"
+#define OMX_ROLE_AUDIO_DECODER_AMRNB    "audio_decoder.amrnb"
+#define OMX_ROLE_AUDIO_DECODER_AMRWB    "audio_decoder.amrwb"
+#define OMX_ROLS_AUDIO_DEXODER_AMRPLUS  "audio_decoder.amrwb+"
+#define OMX_ROLE_AUDIO_DECODER_MP3      "audio_decoder.mp3"
+#define OMX_ROLE_AUDIO_DECODER_RA       "audio_decoder.ra"
+#define OMX_ROLE_AUDIO_DECODER_WMA      "audio_decoder.wma"
+
+/* Audio encoder class */
+#define OMX_ROLE_AUDIO_ENCODER_AAC      "audio_encoder.aac"
+#define OMX_ROLE_AUDIO_ENCODER_AMRNB    "audio_encoder.amrnb"
+#define OMX_ROLE_AUDIO_ENCODER_AMRWB    "audio_encoder.amrwb"
+#define OMX_ROLS_AUDIO_ENCODER_AMRPLUS  "audio_encoder.amrwb+"
+#define OMX_ROLE_AUDIO_ENCODER_MP3      "audio_encoder.mp3"
+
+/* Audio mixer class */
+#define OMX_ROLE_AUDIO_MIXER_PCM "audio_mixer.pcm"
+
+/* Audio reader class */
+#define OMX_ROLE_AUDIO_READER_BINARY "audio_reader.binary"
+
+/* Audio renderer class */
+#define OMX_ROLE_AUDIO_RENDERER_PCM "audio_renderer.pcm"
+
+/* Audio writer class */
+#define OMX_ROLE_AUDIO_WRITER_BINARY "audio_writer.binary"
+
+/* Audio capturer class */
+#define OMX_ROLE_AUDIO_CAPTURER_PCM "audio_capturer.pcm"
+
+/* Audio processor class */
+#define OMX_ROLE_AUDIO_PROCESSOR_PCM_STEREO_WIDENING_LOUDSPEAKERS "audio_processor.pcm.stereo_widening_loudspeakers"
+#define OMX_ROLE_AUDIO_PROCESSOR_PCM_STEREO_WIDENING_HEADPHONES   "audio_processor.pcm.stereo_widening_headphones"
+#define OMX_ROLE_AUDIO_PROCESSOR_PCM_REVERBERATION                "audio_processor.pcm.reverberation"
+#define OMX_ROLE_AUDIO_PROCESSOR_PCM_CHORUS                       "audio_processor.pcm.chorus"
+#define OMX_ROLE_AUDIO_PROCESSOR_PCM_EQUALIZER                    "audio_processor.pcm.equalizer"
+
+/* 3D audio mixer class */
+#define OMX_ROLE_AUDIO_3D_MIXER_PCM_HEADPHONES   "audio_3D_mixer.pcm.headphones"
+#define OMX_ROLE_AUDIO_3D_MIXER_PCM_LOUDSPEAKERS "audio_3D_mixer.pcm.loudspeakers"
+
+/* Image decoder class */
+#define OMX_ROLE_IMAGE_DECODER_JPEG "image_decoder.JPEG"
+
+/* Image encoder class */
+#define OMX_ROLE_IMAGE_ENCODER_JPEG "image_encoder.JPEG"
+
+/* Image reader class */
+#define OMX_ROLE_IMAGE_READER_BINARY "image_reader.binary"
+
+/* Image writer class */
+#define OMX_ROLE_IMAGE_WRITER_BINARY "image_writer.binary"
+
+/* Video decoder class */
+#define OMX_ROLE_VIDEO_DECODER_H263  "video_decoder.h263"
+#define OMX_ROLE_VIDEO_DECODER_AVC   "video_decoder.avc"
+#define OMX_ROLE_VIDEO_DECODER_MPEG4 "video_decoder.mpeg4"
+#define OMX_ROLE_VIDEO_DECODER_MPEG2 "video_decoder.mpeg2"
+#define OMX_ROLE_VIDEO_DECODER_RV    "video_decoder.rv"
+#define OMX_ROLE_VIDEO_DECODER_VP6    "video_decoder.vp6"
+#ifdef ANDROID
+#define OMX_ROLE_VIDEO_DECODER_VP8    "video_decoder.vpx"
+#else
+#define OMX_ROLE_VIDEO_DECODER_VP8    "video_decoder.vp8"
+#endif
+#define OMX_ROLE_VIDEO_DECODER_WMV   "video_decoder.wmv"
+#define OMX_ROLE_VIDEO_DECODER_VC1   "video_decoder.vc1"
+#define OMX_ROLE_VIDEO_DECODER_SORENSON   "video_decoder.sorenson"
+
+/* Video encoder class */
+#define OMX_ROLE_VIDEO_ENCODER_H263  "video_encoder.h263"
+#define OMX_ROLE_VIDEO_ENCODER_AVC   "video_encoder.avc"
+#define OMX_ROLE_VIDEO_ENCODER_MPEG4 "video_encoder.mpeg4"
+
+/* Video reader class */
+#define OMX_ROLE_VIDEO_READER_BINARY "video_reader.binary"
+
+/* Video scheduler class */
+#define OMX_ROLE_VIDEO_SCHEDULER_BINARY "video_scheduler.binary"
+
+/* Video writer class */
+#define OMX_ROLE_VIDEO_WRITER_BINARY "video_writer.binary"
+
+/* Camera class */
+#define OMX_ROLE_CAMERA_YUV "camera.yuv"
+
+/* Clock class */
+#define OMX_ROLE_CLOCK_BINARY "clock.binary"
+
+/* Container demuxer class */
+#define OMX_ROLE_CONTAINER_DEMUXER_3GP  "container_demuxer_3gp"
+#define OMX_ROLE_CONTAINER_DEMUXER_ASF  "container_demuxer_asf"
+#define OMX_ROLE_CONTAINER_DEMUXER_REAL "container_demuxer_real"
+
+/* Container muxer class */
+#define OMX_ROLE_CONTAINER_MUXER_3GP  "container_muxer_3gp"
+
+/* Image/video processor class */
+#define OMX_ROLE_IV_PROCESSOR_YUV "iv_processor.yuv"
+
+/* Image/video rendered class */
+#define OMX_ROLE_IV_RENDERER_YUV_OVERLAY "iv_renderer.yuv.overlay"
+#define OMX_ROLE_IV_RENDERER_YUV_BLTER   "iv_renderer.yuv.blter"
+#define OMX_ROLE_IV_RENDERER_RGB_OVERLAY "iv_renderer.rgb.overlay"
+#define OMX_ROLE_IV_RENDERER_RGB_BLTER   "iv_renderer.rgb.blter"
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/omx/openmax/OMX_Types.h b/omx/openmax/OMX_Types.h
index 71c2909..6c53d7c 100644
--- a/omx/openmax/OMX_Types.h
+++ b/omx/openmax/OMX_Types.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,11 +21,13 @@
  *
  */
 
-/** OMX_Types.h - OpenMax IL version 1.1.2
- *  The OMX_Types header file contains the primitive type definitions used by 
- *  the core, the application and the component.  This file may need to be
- *  modified to be used on systems that do not have "char" set to 8 bits, 
- *  "short" set to 16 bits and "long" set to 32 bits.
+/*
+ *  OMX_Types.h - OpenMax IL version 1.2.0
+ *  The OMX_Types header file contains the primitive type
+ *  definitions used by the core, the application and the
+ *  component.  This file may need to be modified to be used on
+ *  systems that do not have "char" set to 8 bits, "short" set
+ *  to 16 bits and "long" set to 32 bits.
  */
 
 #ifndef OMX_Types_h
@@ -91,60 +93,18 @@ extern "C" {
 #define OMX_INOUT
 #endif
 
-/** OMX_ALL is used to as a wildcard to select all entities of the same type
- *  when specifying the index, or referring to a object by an index.  (i.e.
- *  use OMX_ALL to indicate all N channels). When used as a port index
- *  for a config or parameter this OMX_ALL denotes that the config or
- *  parameter applies to the entire component not just one port. */
 #define OMX_ALL 0xFFFFFFFF
 
-/** In the following we define groups that help building doxygen documentation */
-
-/** @defgroup core OpenMAX IL core
- * Functions and structure related to the OMX IL core
- */
- 
- /** @defgroup comp OpenMAX IL component
- * Functions and structure related to the OMX IL component
- */
- 
-/** @defgroup rpm Resource and Policy Management 
- * Structures for resource and policy management of components
- */
-
-/** @defgroup buf Buffer Management
- * Buffer handling functions and structures
- */
-  
-/** @defgroup tun Tunneling
- * @ingroup core comp
- * Structures and functions to manage tunnels among component ports
- */
- 
-/** @defgroup cp Content Pipes
- *  @ingroup core
- */
- 
- /** @defgroup metadata Metadata handling
-  * 
-  */ 
-
-/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
 typedef unsigned char OMX_U8;
 
-/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
 typedef signed char OMX_S8;
 
-/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
 typedef unsigned short OMX_U16;
 
-/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
 typedef signed short OMX_S16;
 
-/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
 typedef unsigned long OMX_U32;
 
-/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
 typedef signed long OMX_S32;
 
 
@@ -156,135 +116,78 @@ typedef signed long OMX_S32;
 */
 #ifndef OMX_SKIP64BIT
 #ifdef __SYMBIAN32__
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned long long OMX_U64;
 
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
 typedef signed long long OMX_S64;
 
 #elif defined(WIN32)
 
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
 typedef unsigned __int64  OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
 typedef signed   __int64  OMX_S64;
 
 #else /* WIN32 */
 
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
 typedef unsigned long long OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
 typedef signed long long OMX_S64;
 
 #endif /* WIN32 */
 #endif
 
-
-/** The OMX_BOOL type is intended to be used to represent a true or a false 
-    value when passing parameters to and from the OMX core and components.  The
-    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
- */
 typedef enum OMX_BOOL {
     OMX_FALSE = 0,
     OMX_TRUE = !OMX_FALSE,
     OMX_BOOL_MAX = 0x7FFFFFFF
 } OMX_BOOL; 
  
-/** The OMX_PTR type is intended to be used to pass pointers between the OMX
-    applications and the OMX Core and components.  This is a 32 bit pointer and
-    is aligned on a 32 bit boundary.
- */
 typedef void* OMX_PTR;
 
-/** The OMX_STRING type is intended to be used to pass "C" type strings between
-    the application and the core and component.  The OMX_STRING type is a 32 
-    bit pointer to a zero terminated string.  The  pointer is word aligned and 
-    the string is byte aligned.  
- */
 typedef char* OMX_STRING;
 
-/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
-    buffers between the application and the component and core.  The OMX_BYTE 
-    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
-    aligned and the string is byte aligned.
- */
-typedef unsigned char* OMX_BYTE;
-
-/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
-    at runtime.  This identifier should be generated by a component in a way
-    that guarantees that every instance of the identifier running on the system
-    is unique. */
 typedef unsigned char OMX_UUIDTYPE[128];
 
-/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
-    an output port.  This enumeration is common across all component types.    
- */
 typedef enum OMX_DIRTYPE
 {
-    OMX_DirInput,              /**< Port is an input port */
-    OMX_DirOutput,             /**< Port is an output port */
+    OMX_DirInput,
+    OMX_DirOutput,
     OMX_DirMax = 0x7FFFFFFF
 } OMX_DIRTYPE;
 
-/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
-    for numerical data (i.e. big endian, or little endian).    
- */
 typedef enum OMX_ENDIANTYPE
 {
-    OMX_EndianBig, /**< big endian */
-    OMX_EndianLittle, /**< little endian */
+    OMX_EndianBig,
+    OMX_EndianLittle,
     OMX_EndianMax = 0x7FFFFFFF
 } OMX_ENDIANTYPE;
 
-
-/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
-    is signed or unsigned
- */
 typedef enum OMX_NUMERICALDATATYPE
 {
-    OMX_NumericalDataSigned, /**< signed data */
-    OMX_NumericalDataUnsigned, /**< unsigned data */
+    OMX_NumericalDataSigned,
+    OMX_NumericalDataUnsigned,
     OMX_NumercialDataMax = 0x7FFFFFFF
 } OMX_NUMERICALDATATYPE;
 
 
-/** Unsigned bounded value type */
 typedef struct OMX_BU32 {
-    OMX_U32 nValue; /**< actual value */
-    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
-    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+    OMX_U32 nValue;
+    OMX_U32 nMin;
+    OMX_U32 nMax;
 } OMX_BU32;
 
 
-/** Signed bounded value type */
 typedef struct OMX_BS32 {
-    OMX_S32 nValue; /**< actual value */
-    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
-    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+    OMX_S32 nValue;
+    OMX_S32 nMin;
+    OMX_S32 nMax;
 } OMX_BS32;
 
 
-/** Structure representing some time or duration in microseconds. This structure
-  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
-  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
-  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
-  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
-  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
-  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
-  *  or minus 35 minutes).
-  *
-  *  Implementations with limited precision may convert the signed 64 bit value to 
-  *  a signed 32 bit value internally but risk loss of precision.  
-  */
 #ifndef OMX_SKIP64BIT
 typedef OMX_S64 OMX_TICKS;
 #else
 typedef struct OMX_TICKS
 {
-    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
-    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
+    OMX_U32 nLowPart;
+    OMX_U32 nHighPart;
 } OMX_TICKS;
 #endif
 #define OMX_TICKS_PER_SECOND 1000000
@@ -331,10 +234,11 @@ typedef void* OMX_NATIVE_WINDOWTYPE;
     specified by the component vendor.  Components doing the same function
     from different vendors may or may not have the same version.  For 
     structures, the version shall be set by the entity that allocates the
-    structure.  For structures specified in the OMX 1.1 specification, the
-    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
-    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
-    by accessing one of the structure elements to, for example, check only
+    structure.  For structures specified in the OMX 1.2.0
+    specification, the value of the version shall be set to
+    1.2.0.0 in all cases.  Access to the OMX_VERSIONTYPE can be
+    by a single 32 bit access (e.g. by nVersion) or by accessing
+    one of the structure elements to, for example, check only
     the Major revision.
  */
 typedef union OMX_VERSIONTYPE
diff --git a/omx/openmax/OMX_Video.h b/omx/openmax/OMX_Video.h
index 8becf9b..baecca5 100644
--- a/omx/openmax/OMX_Video.h
+++ b/omx/openmax/OMX_Video.h
@@ -1,5 +1,5 @@
-/**
- * Copyright (c) 2008 The Khronos Group Inc. 
+/*
+ * Copyright (c) 2011 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,20 +21,15 @@
  *
  */
 
-/** 
- *  @file OMX_Video.h - OpenMax IL version 1.1.2
+/*
+ *  OMX_Video.h - OpenMax IL version 1.2.0
  *  The structures is needed by Video components to exchange parameters 
  *  and configuration data with OMX components.
  */
+
 #ifndef OMX_Video_h
 #define OMX_Video_h
 
-/** @defgroup video OpenMAX IL Video Domain
- * @ingroup iv
- * Structures for OpenMAX IL Video domain
- * @{
- */
-
 #ifdef __cplusplus
 extern "C" {
 #endif /* __cplusplus */
@@ -48,86 +43,32 @@ extern "C" {
 
 #include <OMX_IVCommon.h>
 
-
-/**
- * Enumeration used to define the possible video compression codings.  
- * NOTE:  This essentially refers to file extensions. If the coding is 
- *        being used to specify the ENCODE type, then additional work 
- *        must be done to configure the exact flavor of the compression 
- *        to be used.  For decode cases where the user application can 
- *        not differentiate between MPEG-4 and H.264 bit streams, it is 
- *        up to the codec to handle this.
- */
 typedef enum OMX_VIDEO_CODINGTYPE {
-    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
-    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
-    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
-    OMX_VIDEO_CodingH263,       /**< H.263 */
-    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
-    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
-    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
-    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
-    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
+    OMX_VIDEO_CodingUnused,
+    OMX_VIDEO_CodingAutoDetect,
+    OMX_VIDEO_CodingMPEG2,
+    OMX_VIDEO_CodingH263,
+    OMX_VIDEO_CodingMPEG4,
+    OMX_VIDEO_CodingWMV,
+    OMX_VIDEO_CodingRV,
+    OMX_VIDEO_CodingAVC,
+    OMX_VIDEO_CodingMJPEG,
+#ifdef ANDROID          /*OMX_HEADER_MODIFICATION - To maintain compatibility with 1_1_2.*/
+    OMX_VIDEO_CodingVPX,
+#else
     OMX_VIDEO_CodingVP8,
+#endif
     OMX_VIDEO_CodingVC1,
     OMX_VIDEO_CodingSorensonSpark,
     OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_CodingVP6,
-    OMX_VIDEO_CodingAVS, 
+    OMX_VIDEO_CodingVP6,                            /**< IMG Vendor Extension */
+    OMX_VIDEO_CodingAVS,                            /**< IMG Vendor Extension */
     OMX_VIDEO_CodingMax = 0x7FFFFFFF
 } OMX_VIDEO_CODINGTYPE;
 
-
-/**
- * Data structure used to define a video path.  The number of Video paths for 
- * input and output will vary by type of the Video component.  
- * 
- *    Input (aka Source) : zero Inputs, one Output,
- *    Splitter           : one Input, 2 or more Outputs,
- *    Processing Element : one Input, one output,
- *    Mixer              : 2 or more inputs, one output,
- *    Output (aka Sink)  : one Input, zero outputs.
- * 
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output video 
- * path.  If additional vendor specific data is required, it should be 
- * transmitted to the component using the CustomCommand function.  Compliant 
- * components will prepopulate this structure with optimal values during the 
- * GetDefaultInitParams command.
- *
- * STRUCT MEMBERS:
- *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a 
- *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on channel if 
- *                          uncompressed format is used.  Use 0 for unknown,
- *                          don't care or variable
- *  nFrameHeight          : Height of frame to be used on channel if 
- *                          uncompressed format is used. Use 0 for unknown,
- *                          don't care or variable
- *  nStride               : Number of bytes per span of an image 
- *                          (i.e. indicates the number of bytes to get
- *                          from span N to span N+1, where negative stride
- *                          indicates the image is bottom up
- *  nSliceHeight          : Height used when encoding in slices
- *  nBitrate              : Bit rate of frame to be used on channel if 
- *                          compressed format is used. Use 0 for unknown, 
- *                          don't care or variable
- *  xFramerate            : Frame rate to be used on channel if uncompressed 
- *                          format is used. Use 0 for unknown, don't care or 
- *                          variable.  Units are Q16 frames per second.
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
- *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of the 
- *                          component. When OMX_VIDEO_CodingUnused is 
- *                          specified, eColorFormat is used
- *  eColorFormat : Decompressed format used by this component
- *  pNativeWindow : Platform specific reference for a window object if a 
- *                          display sink , otherwise this field is 0x0. 
- */
-typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;
+typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {   
+    OMX_STRING cMIMEType;/*OMX_HEADER_MODIFICATION - To maintain compatibility with 1_1_2.*/
     OMX_NATIVE_DEVICETYPE pNativeRender;
     OMX_U32 nFrameWidth;
     OMX_U32 nFrameHeight;
@@ -141,22 +82,6 @@ typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
     OMX_NATIVE_WINDOWTYPE pNativeWindow;
 } OMX_VIDEO_PORTDEFINITIONTYPE;
 
-/**  
- * Port format parameter.  This structure is used to enumerate the various 
- * data input/output format supported by the port.
- * 
- * STRUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information
- *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from 
- *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the 
- *                       component. When OMX_VIDEO_CodingUnused is specified, 
- *                       eColorFormat is used 
- *  eColorFormat       : Decompressed format used by this component
- *  xFrameRate         : Indicates the video frame rate in Q16 format
- */
 typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -167,20 +92,6 @@ typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
     OMX_U32 xFramerate;
 } OMX_VIDEO_PARAM_PORTFORMATTYPE;
 
-
-/**
- * This is a structure for configuring video compression quantization 
- * parameter values.  Codecs may support different QP values for different
- * frame types.
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version info
- *  nPortIndex : Port that this structure applies to
- *  nQpI       : QP value to use for index frames
- *  nQpP       : QP value to use for P frames
- *  nQpB       : QP values to use for bidirectional frames 
- */
 typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
     OMX_U32 nSize;            
     OMX_VERSIONTYPE nVersion;
@@ -190,20 +101,6 @@ typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
     OMX_U32 nQpB;
 } OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
 
-
-/** 
- * Structure for configuration of video fast update parameters. 
- *  
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version info 
- *  nPortIndex : Port that this structure applies to
- *  bEnableVFU : Enable/Disable video fast update
- *  nFirstGOB  : Specifies the number of the first macroblock row
- *  nFirstMB   : specifies the first MB relative to the specified first GOB
- *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB 
- *               and nFirstMB
- */
 typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
     OMX_U32 nSize;            
     OMX_VERSIONTYPE nVersion; 
@@ -214,10 +111,6 @@ typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
     OMX_U32 nNumMBs;                                  
 } OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
 
-
-/** 
- * Enumeration of possible bitrate control types 
- */
 typedef enum OMX_VIDEO_CONTROLRATETYPE {
     OMX_Video_ControlRateDisable,
     OMX_Video_ControlRateVariable,
@@ -229,17 +122,6 @@ typedef enum OMX_VIDEO_CONTROLRATETYPE {
     OMX_Video_ControlRateMax = 0x7FFFFFFF
 } OMX_VIDEO_CONTROLRATETYPE;
 
-
-/** 
- * Structure for configuring bitrate mode of a codec. 
- *
- * STRUCT MEMBERS:
- *  nSize          : Size of the struct in bytes
- *  nVersion       : OMX spec version info
- *  nPortIndex     : Port that this struct applies to
- *  eControlRate   : Control rate type enum
- *  nTargetBitrate : Target bitrate to encode with
- */
 typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
     OMX_U32 nSize;                          
     OMX_VERSIONTYPE nVersion;               
@@ -248,10 +130,6 @@ typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
     OMX_U32 nTargetBitrate;                 
 } OMX_VIDEO_PARAM_BITRATETYPE;
 
-
-/** 
- * Enumeration of possible motion vector (MV) types 
- */
 typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
     OMX_Video_MotionVectorPixel,
     OMX_Video_MotionVectorHalfPel,
@@ -262,21 +140,6 @@ typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
     OMX_Video_MotionVectorMax = 0x7FFFFFFF
 } OMX_VIDEO_MOTIONVECTORTYPE;
 
-
-/**
- * Structure for configuring the number of motion vectors used as well
- * as their accuracy.
- * 
- * STRUCT MEMBERS:
- *  nSize            : Size of the struct in bytes
- *  nVersion         : OMX spec version info
- *  nPortIndex       : port that this structure applies to
- *  eAccuracy        : Enumerated MV accuracy
- *  bUnrestrictedMVs : Allow unrestricted MVs
- *  bFourMV          : Allow use of 4 MVs
- *  sXSearchRange    : Search range in horizontal direction for MVs
- *  sYSearchRange    : Search range in vertical direction for MVs
- */
 typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -288,10 +151,6 @@ typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
     OMX_S32 sYSearchRange;
 } OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
 
-
-/** 
- * Enumeration of possible methods to use for Intra Refresh 
- */
 typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
     OMX_VIDEO_IntraRefreshCyclic,
     OMX_VIDEO_IntraRefreshAdaptive,
@@ -301,22 +160,6 @@ typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
     OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
 } OMX_VIDEO_INTRAREFRESHTYPE;
 
-
-/**
- * Structure for configuring intra refresh mode 
- * 
- * STRUCT MEMBERS:
- *  nSize        : Size of the structure in bytes
- *  nVersion     : OMX specification version information
- *  nPortIndex   : Port that this structure applies to
- *  eRefreshMode : Cyclic, Adaptive, or Both
- *  nAirMBs      : Number of intra macroblocks to refresh in a frame when 
- *                 AIR is enabled
- *  nAirRef      : Number of times a motion marked macroblock has to be  
- *                 intra coded
- *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"  
- *                 when CIR is enabled
- */
 typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -327,23 +170,6 @@ typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
     OMX_U32 nCirMBs;
 } OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
 
-
-/**
- * Structure for enabling various error correction methods for video 
- * compression.
- *
- * STRUCT MEMBERS:
- *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information 
- *  nPortIndex              : Port that this structure applies to 
- *  bEnableHEC              : Enable/disable header extension codes (HEC)
- *  bEnableResync           : Enable/disable resynchronization markers
- *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be 
- *                            applied in the stream 
- *  bEnableDataPartitioning : Enable/disable data partitioning 
- *  bEnableRVLC             : Enable/disable reversible variable length 
- *                            coding
- */
 typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -355,22 +181,6 @@ typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
     OMX_BOOL bEnableRVLC;
 } OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
 
-
-/** 
- * Configuration of variable block-size motion compensation (VBSMC) 
- * 
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  b16x16     : Enable inter block search 16x16
- *  b16x8      : Enable inter block search 16x8
- *  b8x16      : Enable inter block search 8x16
- *  b8x8       : Enable inter block search 8x8
- *  b8x4       : Enable inter block search 8x4
- *  b4x8       : Enable inter block search 4x8
- *  b4x4       : Enable inter block search 4x4
- */
 typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
     OMX_U32 nSize; 
     OMX_VERSIONTYPE nVersion; 
@@ -384,31 +194,6 @@ typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
     OMX_BOOL b4x4;
 } OMX_VIDEO_PARAM_VBSMCTYPE;
 
-
-/** 
- * H.263 profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- *
- * ENUMS:
- *  Baseline           : Baseline Profile: H.263 (V1), no optional modes                                                    
- *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility 
- *                       Profile: H.263+ (V2), includes annexes I, J, L.4
- *                       and T
- *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1), 
- *                       includes annex F                                    
- *  ISWV2              : Interactive Streaming Wireless Profile: H.263+ 
- *                       (V2), includes annexes I, J, K and T                 
- *  ISWV3              : Interactive Streaming Wireless Profile: H.263++  
- *                       (V3), includes profile 3 and annexes V and W.6.3.8   
- *  HighCompression    : Conversational High Compression Profile: H.263++  
- *                       (V3), includes profiles 1 & 2 and annexes D and U   
- *  Internet           : Conversational Internet Profile: H.263++ (V3),  
- *                       includes profile 5 and annex K                       
- *  Interlace          : Conversational Interlace Profile: H.263++ (V3),  
- *                       includes profile 5 and annex W.6.3.11               
- *  HighLatency        : High Latency Profile: H.263++ (V3), includes  
- *                       profile 6 and annexes O.1 and P.5                       
- */
 typedef enum OMX_VIDEO_H263PROFILETYPE {
     OMX_VIDEO_H263ProfileBaseline            = 0x01,        
     OMX_VIDEO_H263ProfileH320Coding          = 0x02,          
@@ -419,16 +204,12 @@ typedef enum OMX_VIDEO_H263PROFILETYPE {
     OMX_VIDEO_H263ProfileInternet            = 0x40,            
     OMX_VIDEO_H263ProfileInterlace           = 0x80,           
     OMX_VIDEO_H263ProfileHighLatency         = 0x100,         
+    OMX_VIDEO_H263ProfileUnknown             = 0x6EFFFFFF,
     OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF  
 } OMX_VIDEO_H263PROFILETYPE;
 
-
-/** 
- * H.263 level types, each level indicates support for various frame sizes, 
- * bit rates, decoder frame rates.
- */
 typedef enum OMX_VIDEO_H263LEVELTYPE {
     OMX_VIDEO_H263Level10  = 0x01,  
     OMX_VIDEO_H263Level20  = 0x02,      
@@ -438,63 +219,24 @@ typedef enum OMX_VIDEO_H263LEVELTYPE {
     OMX_VIDEO_H263Level50  = 0x20,      
     OMX_VIDEO_H263Level60  = 0x40,      
     OMX_VIDEO_H263Level70  = 0x80, 
+    OMX_VIDEO_H263LevelUnknown           = 0x6EFFFFFF,
     OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_H263LevelMax = 0x7FFFFFFF  
 } OMX_VIDEO_H263LEVELTYPE;
 
-
-/** 
- * Specifies the picture type. These values should be OR'd to signal all 
- * pictures types which are allowed.
- *
- * ENUMS:
- *  Generic Picture Types:          I, P and B
- *  H.263 Specific Picture Types:   SI and SP
- *  H.264 Specific Picture Types:   EI and EP
- *  MPEG-4 Specific Picture Types:  S
- */
 typedef enum OMX_VIDEO_PICTURETYPE {
-    OMX_VIDEO_PictureTypeI   = 0x01,
-    OMX_VIDEO_PictureTypeP   = 0x02,
-    OMX_VIDEO_PictureTypeB   = 0x04,
-    OMX_VIDEO_PictureTypeSI  = 0x08,
-    OMX_VIDEO_PictureTypeSP  = 0x10,
-    OMX_VIDEO_PictureTypeEI  = 0x11,
-    OMX_VIDEO_PictureTypeEP  = 0x12,
-    OMX_VIDEO_PictureTypeS   = 0x14,
-    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_PictureTypeI   = (1 << 0),
+    OMX_VIDEO_PictureTypeP   = (1 << 1),
+    OMX_VIDEO_PictureTypeB   = (1 << 2),
+    OMX_VIDEO_PictureTypeSI  = (1 << 3),
+    OMX_VIDEO_PictureTypeSP  = (1 << 4),
+    OMX_VIDEO_PictureTypeEI  = (1 << 5),
+    OMX_VIDEO_PictureTypeEP  = (1 << 6),
+    OMX_VIDEO_PictureTypeS   = (1 << 7),
     OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
 } OMX_VIDEO_PICTURETYPE;
 
-
-/** 
- * H.263 Params 
- *
- * STRUCT MEMBERS:
- *  nSize                    : Size of the structure in bytes
- *  nVersion                 : OMX specification version information 
- *  nPortIndex               : Port that this structure applies to
- *  nPFrames                 : Number of P frames between each I frame
- *  nBFrames                 : Number of B frames between each I frame
- *  eProfile                 : H.263 profile(s) to use
- *  eLevel                   : H.263 level(s) to use
- *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE 
- *                             (specified in the 1998 version of H.263) to 
- *                             indicate custom picture sizes or clock 
- *                             frequencies 
- *  nAllowedPictureTypes     : Specifies the picture types allowed in the 
- *                             bitstream
- *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is 
- *                             not constrained. It is recommended to change 
- *                             the value of the RTYPE bit for each reference 
- *                             picture in error-free communication
- *  nPictureHeaderRepetition : Specifies the frequency of picture header 
- *                             repetition
- *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB  
- *                             headers in units of GOBs
- */
 typedef struct OMX_VIDEO_PARAM_H263TYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -502,7 +244,7 @@ typedef struct OMX_VIDEO_PARAM_H263TYPE {
     OMX_U32 nPFrames;
     OMX_U32 nBFrames;
     OMX_VIDEO_H263PROFILETYPE eProfile;
-	OMX_VIDEO_H263LEVELTYPE eLevel;
+    OMX_VIDEO_H263LEVELTYPE eLevel;
     OMX_BOOL bPLUSPTYPEAllowed;
     OMX_U32 nAllowedPictureTypes;
     OMX_BOOL bForceRoundingTypeToZero;
@@ -510,51 +252,30 @@ typedef struct OMX_VIDEO_PARAM_H263TYPE {
     OMX_U32 nGOBHeaderInterval;
 } OMX_VIDEO_PARAM_H263TYPE;
 
-
-/** 
- * MPEG-2 profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- */
 typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
-    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
-    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
-    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
-    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
-    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
-    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
+    OMX_VIDEO_MPEG2ProfileSimple = 0,
+    OMX_VIDEO_MPEG2ProfileMain,
+    OMX_VIDEO_MPEG2Profile422,
+    OMX_VIDEO_MPEG2ProfileSNR,
+    OMX_VIDEO_MPEG2ProfileSpatial,
+    OMX_VIDEO_MPEG2ProfileHigh,
+    OMX_VIDEO_MPEG2ProfileUnknown           = 0x6EFFFFFF,
     OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF  
 } OMX_VIDEO_MPEG2PROFILETYPE;
 
-
-/** 
- * MPEG-2 level types, each level indicates support for various frame 
- * sizes, bit rates, decoder frame rates.  No need 
- */
 typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
-    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */ 
-    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */ 
-    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */ 
-    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */   
+    OMX_VIDEO_MPEG2LevelLL = 0,
+    OMX_VIDEO_MPEG2LevelML,
+    OMX_VIDEO_MPEG2LevelH14,
+    OMX_VIDEO_MPEG2LevelHL,
+    OMX_VIDEO_MPEG2LevelUnknown           = 0x6EFFFFFF,
     OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF  
 } OMX_VIDEO_MPEG2LEVELTYPE;
 
-
-/** 
- * MPEG-2 params 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nPFrames   : Number of P frames between each I frame
- *  nBFrames   : Number of B frames between each I frame
- *  eProfile   : MPEG-2 profile(s) to use
- *  eLevel     : MPEG-2 levels(s) to use
- */
 typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
     OMX_U32 nSize;           
     OMX_VERSIONTYPE nVersion;
@@ -562,31 +283,9 @@ typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
     OMX_U32 nPFrames;        
     OMX_U32 nBFrames;        
     OMX_VIDEO_MPEG2PROFILETYPE eProfile;
-	OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
+    OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
 } OMX_VIDEO_PARAM_MPEG2TYPE;
 
-
-/** 
- * MPEG-4 profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- * 
- * ENUMS:
- *  - Simple Profile, Levels 1-3
- *  - Simple Scalable Profile, Levels 1-2
- *  - Core Profile, Levels 1-2
- *  - Main Profile, Levels 2-4
- *  - N-bit Profile, Level 2
- *  - Scalable Texture Profile, Level 1
- *  - Simple Face Animation Profile, Levels 1-2
- *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
- *  - Basic Animated Texture Profile, Levels 1-2
- *  - Hybrid Profile, Levels 1-2
- *  - Advanced Real Time Simple Profiles, Levels 1-4
- *  - Core Scalable Profile, Levels 1-3
- *  - Advanced Coding Efficiency Profile, Levels 1-4
- *  - Advanced Core Profile, Levels 1-2
- *  - Advanced Scalable Texture, Levels 2-3
- */
 typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
     OMX_VIDEO_MPEG4ProfileSimple           = 0x01,        
     OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,    
@@ -604,59 +303,27 @@ typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
     OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,      
     OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
     OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
+    OMX_VIDEO_MPEG4ProfileUnknown          = 0x6EFFFFFF,
     OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF  
 } OMX_VIDEO_MPEG4PROFILETYPE;
 
-
-/** 
- * MPEG-4 level types, each level indicates support for various frame 
- * sizes, bit rates, decoder frame rates.  No need 
- */
 typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
-    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */   
-    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */   
-    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */ 
-    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */ 
-    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */ 
-    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */  
-    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */  
-    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */  
+    OMX_VIDEO_MPEG4Level0  = 0x01,
+    OMX_VIDEO_MPEG4Level0b = 0x02,
+    OMX_VIDEO_MPEG4Level1  = 0x04,
+    OMX_VIDEO_MPEG4Level2  = 0x08,
+    OMX_VIDEO_MPEG4Level3  = 0x10,
+    OMX_VIDEO_MPEG4Level4  = 0x20,
+    OMX_VIDEO_MPEG4Level4a = 0x40,
+    OMX_VIDEO_MPEG4Level5  = 0x80,
+    OMX_VIDEO_MPEG4LevelUnknown           = 0x6EFFFFFF,
     OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF  
 } OMX_VIDEO_MPEG4LEVELTYPE;
 
-
-/** 
- * MPEG-4 configuration.  This structure handles configuration options
- * which are specific to MPEG4 algorithms
- *
- * STRUCT MEMBERS:
- *  nSize                : Size of the structure in bytes
- *  nVersion             : OMX specification version information
- *  nPortIndex           : Port that this structure applies to
- *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+ 
- *                         Annex K). Put zero if not used
- *  bSVH                 : Enable Short Video Header mode
- *  bGov                 : Flag to enable GOV
- *  nPFrames             : Number of P frames between each I frame (also called 
- *                         GOV period)
- *  nBFrames             : Number of B frames between each I frame
- *  nIDCVLCThreshold     : Value of intra DC VLC threshold
- *  bACPred              : Flag to use ac prediction
- *  nMaxPacketSize       : Maximum size of packet in bytes.
- *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4. 
- *                         Interpreted as described in MPEG4 standard.
- *  eProfile             : MPEG-4 profile(s) to use.
- *  eLevel               : MPEG-4 level(s) to use.
- *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
- *  nHeaderExtension     : Specifies the number of consecutive video packet
- *                         headers within a VOP
- *  bReversibleVLC       : Specifies whether reversible variable length coding 
- *                         is in use
- */
 typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -677,30 +344,40 @@ typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
     OMX_BOOL bReversibleVLC;
 } OMX_VIDEO_PARAM_MPEG4TYPE;
 
-
-/** 
- * WMV Versions 
- */
 typedef enum OMX_VIDEO_WMVFORMATTYPE {
-    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
-    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
-    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
-    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
+    OMX_VIDEO_WMVFormatUnused = 0x01,
+    OMX_VIDEO_WMVFormat7      = 0x02,
+    OMX_VIDEO_WMVFormat8      = 0x04,
+    OMX_VIDEO_WMVFormat9      = 0x08,
+    OMX_VIDEO_WMVFormatUnknown           = 0x6EFFFFFF,
     OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
 } OMX_VIDEO_WMVFORMATTYPE;
 
+typedef enum OMX_VIDEO_WMVPROFILETYPE {
+    OMX_VIDEO_WMVProfileSimple = 0,
+    OMX_VIDEO_WMVProfileMain,
+    OMX_VIDEO_WMVProfileAdvanced,
+    OMX_VIDEO_WMVProfileUnknown           = 0x6EFFFFFF,
+    OMX_VIDEO_WMVProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_WMVProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+} OMX_VIDEO_WMVPROFILETYPE;
+
+typedef enum OMX_VIDEO_WMVLEVELTYPE {
+    OMX_VIDEO_WMVLevelLow = 0,
+    OMX_VIDEO_WMVLevelMedium,
+    OMX_VIDEO_WMVLevelHigh,
+    OMX_VIDEO_WMVLevelL0,
+    OMX_VIDEO_WMVLevelL1,
+    OMX_VIDEO_WMVLevelL2,
+    OMX_VIDEO_WMVLevelL3,
+    OMX_VIDEO_WMVLevelL4,
+    OMX_VIDEO_WMVLevelUnknown           = 0x6EFFFFFF,
+    OMX_VIDEO_WMVLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_WMVLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+} OMX_VIDEO_WMVLEVELTYPE;
 
-/** 
- * WMV Params 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  eFormat    : Version of WMV stream / data
- */
 typedef struct OMX_VIDEO_PARAM_WMVTYPE {
     OMX_U32 nSize; 
     OMX_VERSIONTYPE nVersion;
@@ -708,44 +385,17 @@ typedef struct OMX_VIDEO_PARAM_WMVTYPE {
     OMX_VIDEO_WMVFORMATTYPE eFormat;
 } OMX_VIDEO_PARAM_WMVTYPE;
 
-
-/** 
- * Real Video Version 
- */
 typedef enum OMX_VIDEO_RVFORMATTYPE {
-    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
-    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
-    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
-    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
+    OMX_VIDEO_RVFormatUnused = 0,
+    OMX_VIDEO_RVFormat8,
+    OMX_VIDEO_RVFormat9,
+    OMX_VIDEO_RVFormatG2,
+    OMX_VIDEO_RVFormatUnknown           = 0x6EFFFFFF,
     OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
 } OMX_VIDEO_RVFORMATTYPE;
 
-
-/** 
- * Real Video Params 
- *
- * STUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information 
- *  nPortIndex         : Port that this structure applies to
- *  eFormat            : Version of RV stream / data
- *  nBitsPerPixel      : Bits per pixel coded in the frame
- *  nPaddedWidth       : Padded width in pixel of a video frame
- *  nPaddedHeight      : Padded Height in pixels of a video frame
- *  nFrameRate         : Rate of video in frames per second
- *  nBitstreamFlags    : Flags which internal information about the bitstream
- *  nBitstreamVersion  : Bitstream version
- *  nMaxEncodeFrameSize: Max encoded frame size
- *  bEnablePostFilter  : Turn on/off post filter
- *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
- *  bEnableLatencyMode : When enabled, the decoder does not display a decoded 
- *                       frame until it has detected that no enhancement layer 
- *  					 frames or dependent B frames will be coming. This 
- *  					 detection usually occurs when a subsequent non-B 
- *  					 frame is encountered 
- */
 typedef struct OMX_VIDEO_PARAM_RVTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -763,59 +413,43 @@ typedef struct OMX_VIDEO_PARAM_RVTYPE {
     OMX_BOOL bEnableLatencyMode;
 } OMX_VIDEO_PARAM_RVTYPE;
 
-
-/** 
- * AVC profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- */
 typedef enum OMX_VIDEO_AVCPROFILETYPE {
-    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
-    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
-    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
-    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
-    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
-    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
-    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
+    OMX_VIDEO_AVCProfileBaseline = 0x01,
+    OMX_VIDEO_AVCProfileMain     = 0x02,
+    OMX_VIDEO_AVCProfileExtended = 0x04,
+    OMX_VIDEO_AVCProfileHigh     = 0x08,
+    OMX_VIDEO_AVCProfileHigh10   = 0x10,
+    OMX_VIDEO_AVCProfileHigh422  = 0x20,
+    OMX_VIDEO_AVCProfileHigh444  = 0x40,
+    OMX_VIDEO_AVCProfileUnknown  = 0x6EFFFFFF,
     OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF  
 } OMX_VIDEO_AVCPROFILETYPE;
 
-
-/** 
- * AVC level types, each level indicates support for various frame sizes, 
- * bit rates, decoder frame rates.  No need 
- */
 typedef enum OMX_VIDEO_AVCLEVELTYPE {
-    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
-    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
-    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
-    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
-    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
-    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
-    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
-    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
-    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
-    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
-    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
-    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
-    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
-    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
-    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
-    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
+    OMX_VIDEO_AVCLevel1   = 0x01,
+    OMX_VIDEO_AVCLevel1b  = 0x02,
+    OMX_VIDEO_AVCLevel11  = 0x04,
+    OMX_VIDEO_AVCLevel12  = 0x08,
+    OMX_VIDEO_AVCLevel13  = 0x10,
+    OMX_VIDEO_AVCLevel2   = 0x20,
+    OMX_VIDEO_AVCLevel21  = 0x40,
+    OMX_VIDEO_AVCLevel22  = 0x80,
+    OMX_VIDEO_AVCLevel3   = 0x100,
+    OMX_VIDEO_AVCLevel31  = 0x200,
+    OMX_VIDEO_AVCLevel32  = 0x400,
+    OMX_VIDEO_AVCLevel4   = 0x800,
+    OMX_VIDEO_AVCLevel41  = 0x1000,
+    OMX_VIDEO_AVCLevel42  = 0x2000,
+    OMX_VIDEO_AVCLevel5   = 0x4000,
+    OMX_VIDEO_AVCLevel51  = 0x8000,
+    OMX_VIDEO_AVCLevelUnknown           = 0x6EFFFFFF,
     OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF  
 } OMX_VIDEO_AVCLEVELTYPE;
 
-
-/** 
- * AVC loop filter modes 
- *
- * OMX_VIDEO_AVCLoopFilterEnable               : Enable
- * OMX_VIDEO_AVCLoopFilterDisable              : Disable
- * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
- */
 typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
     OMX_VIDEO_AVCLoopFilterEnable = 0,
     OMX_VIDEO_AVCLoopFilterDisable,
@@ -825,60 +459,6 @@ typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
     OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
 } OMX_VIDEO_AVCLOOPFILTERTYPE;
 
-
-/** 
- * AVC params 
- *
- * STRUCT MEMBERS:
- *  nSize                     : Size of the structure in bytes
- *  nVersion                  : OMX specification version information
- *  nPortIndex                : Port that this structure applies to
- *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put  
- *                              zero if not used
- *  nPFrames                  : Number of P frames between each I frame
- *  nBFrames                  : Number of B frames between each I frame
- *  bUseHadamard              : Enable/disable Hadamard transform
- *  nRefFrames                : Max number of reference frames to use for inter
- *                              motion search (1-16)
- *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
- *                              frame buffer of trailing frames list), B frame
- *                              support
- *  nRefIdxForward            : Pic param set ref frame index (index into ref
- *                              frame buffer of forward frames list), B frame
- *                              support
- *  bEnableUEP                : Enable/disable unequal error protection. This 
- *                              is only valid of data partitioning is enabled.
- *  bEnableFMO                : Enable/disable flexible macroblock ordering
- *  bEnableASO                : Enable/disable arbitrary slice ordering
- *  bEnableRS                 : Enable/disable sending of redundant slices
- *  eProfile                  : AVC profile(s) to use
- *  eLevel                    : AVC level(s) to use
- *  nAllowedPictureTypes      : Specifies the picture types allowed in the 
- *                              bitstream
- *  bFrameMBsOnly             : specifies that every coded picture of the 
- *                              coded video sequence is a coded frame 
- *                              containing only frame macroblocks
- *  bMBAFF                    : Enable/disable switching between frame and 
- *                              field macroblocks within a picture
- *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the 
- *                              syntax elements for which two descriptors appear 
- *                              in the syntax tables
- *  bWeightedPPrediction      : Enable/disable weighted prediction shall not 
- *                              be applied to P and SP slices
- *  nWeightedBipredicitonMode : Default weighted prediction is applied to B 
- *                              slices 
- *  bconstIpred               : Enable/disable intra prediction
- *  bDirect8x8Inference       : Specifies the method used in the derivation 
- *                              process for luma motion vectors for B_Skip, 
- *                              B_Direct_16x16 and B_Direct_8x8 as specified 
- *                              in subclause 8.4.1.2 of the AVC spec 
- *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
- *                              mode used in B slice coding (related to 
- *                              bDirect8x8Inference) . Spatial direct mode is 
- *                              more common and should be the default.
- *  nCabacInitIdx             : Index used to init CABAC contexts
- *  eLoopFilterMode           : Enable/disable loop filter
- */
 typedef struct OMX_VIDEO_PARAM_AVCTYPE {
     OMX_U32 nSize;                 
     OMX_VERSIONTYPE nVersion;      
@@ -888,50 +468,87 @@ typedef struct OMX_VIDEO_PARAM_AVCTYPE {
     OMX_U32 nBFrames;     
     OMX_BOOL bUseHadamard;
     OMX_U32 nRefFrames;  
-	OMX_U32 nRefIdx10ActiveMinus1;
-	OMX_U32 nRefIdx11ActiveMinus1;
+    OMX_U32 nRefIdx10ActiveMinus1;
+    OMX_U32 nRefIdx11ActiveMinus1;
     OMX_BOOL bEnableUEP;  
     OMX_BOOL bEnableFMO;  
     OMX_BOOL bEnableASO;  
     OMX_BOOL bEnableRS;   
     OMX_VIDEO_AVCPROFILETYPE eProfile;
-	OMX_VIDEO_AVCLEVELTYPE eLevel; 
+    OMX_VIDEO_AVCLEVELTYPE eLevel; 
     OMX_U32 nAllowedPictureTypes;  
-	OMX_BOOL bFrameMBsOnly;        									
+    OMX_BOOL bFrameMBsOnly;                                         
     OMX_BOOL bMBAFF;               
     OMX_BOOL bEntropyCodingCABAC;  
     OMX_BOOL bWeightedPPrediction; 
     OMX_U32 nWeightedBipredicitonMode; 
     OMX_BOOL bconstIpred ;
     OMX_BOOL bDirect8x8Inference;  
-	OMX_BOOL bDirectSpatialTemporal;
-	OMX_U32 nCabacInitIdc;
-	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
+    OMX_BOOL bDirectSpatialTemporal;
+    OMX_U32 nCabacInitIdc;
+    OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
 } OMX_VIDEO_PARAM_AVCTYPE;
 
+
+typedef enum OMX_VIDEO_VP84PROFILETYPE {
+    OMX_VIDEO_VP8ProfileMain                = 0x01,        
+    OMX_VIDEO_VP8ProfileUnknown             = 0x6EFFFFFF,
+    OMX_VIDEO_VP8ProfileKhronosExtensions   = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_VP8ProfileVendorStartUnused   = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_VP8ProfileMax                 = 0x7FFFFFFF  
+} OMX_VIDEO_VP8PROFILETYPE;
+
+typedef enum OMX_VIDEO_VP8LEVELTYPE {
+    OMX_VIDEO_VP8Level_Version0             = 0x01,
+    OMX_VIDEO_VP8Level_Version1             = 0x02,
+    OMX_VIDEO_VP8Level_Version2             = 0x04,
+    OMX_VIDEO_VP8Level_Version3             = 0x08,
+    OMX_VIDEO_VP8LevelUnknown               = 0x6EFFFFFF,
+    OMX_VIDEO_VP8LevelKhronosExtensions     = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_VP8LevelVendorStartUnused     = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_VP8LevelMax                   = 0x7FFFFFFF  
+} OMX_VIDEO_VP8LEVELTYPE;
+
+typedef struct OMX_VIDEO_PARAM_VP8TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_VP8PROFILETYPE eProfile;
+    OMX_VIDEO_VP8LEVELTYPE eLevel;
+    OMX_U32 nDCTPartitions;
+    OMX_BOOL bErrorResilientMode;
+} OMX_VIDEO_PARAM_VP8TYPE;
+
+typedef struct OMX_VIDEO_VP8REFERENCEFRAMETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL nPreviousFrameRefresh;
+    OMX_BOOL bGoldenFrameRefresh;
+    OMX_BOOL bAlternateFrameRefresh;
+    OMX_BOOL bUsePreviousFrame;
+    OMX_BOOL bUseGoldenFrame;
+    OMX_BOOL bUseAlternateFrame;
+} OMX_VIDEO_VP8REFERENCEFRAMETYPE ;
+
+typedef struct OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bIsIntraFrame;
+    OMX_BOOL bIsGoldenOrAlternateFrame;
+} OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE ;
+
 typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
    OMX_U32 nSize;                 
    OMX_VERSIONTYPE nVersion;      
    OMX_U32 nPortIndex;            
-   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
-                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
-                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
-                               This parameter is valid only for 
-                               OMX_IndexParamVideoProfileLevelQuerySupported index,
-                               For all other indices this parameter is to be ignored. */
+   OMX_U32 eProfile;
+   OMX_U32 eLevel;
+   OMX_U32 nIndex;
+   OMX_U32 eCodecType;
 } OMX_VIDEO_PARAM_PROFILELEVELTYPE;
 
-/** 
- * Structure for dynamically configuring bitrate mode of a codec. 
- *
- * STRUCT MEMBERS:
- *  nSize          : Size of the struct in bytes
- *  nVersion       : OMX spec version info
- *  nPortIndex     : Port that this struct applies to
- *  nEncodeBitrate : Target average bitrate to be generated in bps
- */
 typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
     OMX_U32 nSize;                          
     OMX_VERSIONTYPE nVersion;               
@@ -939,20 +556,11 @@ typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
     OMX_U32 nEncodeBitrate;                 
 } OMX_VIDEO_CONFIG_BITRATETYPE;
 
-/** 
- * Defines Encoder Frame Rate setting
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes
- *  nVersion         : OMX specification version information 
- *  nPortIndex       : Port that this structure applies to
- *  xEncodeFramerate : Encoding framerate represented in Q16 format
- */
 typedef struct OMX_CONFIG_FRAMERATETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
-    OMX_U32 xEncodeFramerate; /* Q16 format */
+    OMX_U32 xEncodeFramerate;
 } OMX_CONFIG_FRAMERATETYPE;
 
 typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
@@ -966,8 +574,8 @@ typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
-    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
-    OMX_U8  ErrMap[1];             /* Error map hint */
+    OMX_U32 nErrMapSize;
+    OMX_U8  ErrMap[1];
 } OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
 
 typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
@@ -984,13 +592,6 @@ typedef struct OMX_PARAM_MACROBLOCKSTYPE {
     OMX_U32 nMacroblocks;
 } OMX_PARAM_MACROBLOCKSTYPE;
 
-/** 
- * AVC Slice Mode modes 
- *
- * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
- * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
- * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
- */
 typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
     OMX_VIDEO_SLICEMODE_AVCDefault = 0,
     OMX_VIDEO_SLICEMODE_AVCMBSlice,
@@ -1000,17 +601,6 @@ typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
     OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
 } OMX_VIDEO_AVCSLICEMODETYPE;
 
-/** 
- * AVC FMO Slice Mode Params 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nNumSliceGroups : Specifies the number of slice groups
- *  nSliceGroupMapType : Specifies the type of slice groups
- *  eSliceMode : Specifies the type of slice
- */
 typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
     OMX_U32 nSize; 
     OMX_VERSIONTYPE nVersion;
@@ -1020,16 +610,6 @@ typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
     OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
 } OMX_VIDEO_PARAM_AVCSLICEFMO;
 
-/** 
- * AVC IDR Period Configs
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nIDRPeriod : Specifies periodicity of IDR frames
- *  nPFrames : Specifies internal of coding Intra frames
- */
 typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
     OMX_U32 nSize; 
     OMX_VERSIONTYPE nVersion;
@@ -1038,15 +618,6 @@ typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
     OMX_U32 nPFrames;
 } OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
 
-/** 
- * AVC NAL Size Configs
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nNaluBytes : Specifies the NAL unit size
- */
 typedef struct OMX_VIDEO_CONFIG_NALSIZE {
     OMX_U32 nSize; 
     OMX_VERSIONTYPE nVersion;
@@ -1054,7 +625,112 @@ typedef struct OMX_VIDEO_CONFIG_NALSIZE {
     OMX_U32 nNaluBytes;
 } OMX_VIDEO_CONFIG_NALSIZE;
 
-/** @} */
+typedef enum OMX_NALUFORMATSTYPE {
+    OMX_NaluFormatStartCodes = 1,
+    OMX_NaluFormatOneNaluPerBuffer = 2,
+    OMX_NaluFormatOneByteInterleaveLength = 4,
+    OMX_NaluFormatTwoByteInterleaveLength = 8,
+    OMX_NaluFormatFourByteInterleaveLength = 16,
+    OMX_NaluFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_NaluFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_NaluFormatCodingMax = 0x7FFFFFFF
+} OMX_NALUFORMATSTYPE;
+
+typedef struct OMX_NALSTREAMFORMATTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_NALUFORMATSTYPE eNaluFormat;
+} OMX_NALSTREAMFORMATTYPE;
+
+typedef enum OMX_VIDEO_VC1PROFILETYPE {
+    OMX_VIDEO_VC1ProfileUnused = 0,
+    OMX_VIDEO_VC1ProfileSimple,
+    OMX_VIDEO_VC1ProfileMain,
+    OMX_VIDEO_VC1ProfileAdvanced,
+    OMX_VIDEO_VC1ProfileUnknown           = 0x6EFFFFFF,
+    OMX_VIDEO_VC1ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_VC1ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_VC1ProfileMax
+} OMX_VIDEO_VC1PROFILETYPE;
+
+typedef enum OMX_VIDEO_VC1LEVELTYPE {
+    OMX_VIDEO_VC1LevelUnused = 0,
+    OMX_VIDEO_VC1LevelLow,
+    OMX_VIDEO_VC1LevelMedium,
+    OMX_VIDEO_VC1LevelHigh,
+    OMX_VIDEO_VC1Level0,
+    OMX_VIDEO_VC1Level1,
+    OMX_VIDEO_VC1Level2,
+    OMX_VIDEO_VC1Level3,
+    OMX_VIDEO_VC1Level4,
+    OMX_VIDEO_VC1LevelUnknown           = 0x6EFFFFFF,
+    OMX_VIDEO_VC1LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_VC1LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_VC1LevelMax
+} OMX_VIDEO_VC1LEVELTYPE;
+
+typedef struct OMX_VIDEO_PARAM_VC1TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_VC1PROFILETYPE eProfile;
+    OMX_VIDEO_VC1LEVELTYPE eLevel;
+} OMX_VIDEO_PARAM_VC1TYPE;
+
+typedef struct OMX_VIDEO_INTRAPERIODTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIDRPeriod;
+    OMX_S32 nPFrames;
+    OMX_S32 nBFrames;
+} OMX_VIDEO_INTRAPERIODTYPE;
+
+
+/* Following Interlace related structures are added by IMG as part of 
+   passing Interlace related information to IL Client on Sequence and
+   frame basis. Only those structures/fields used by IMG are copied 
+   below from OpenMAX 1.2 header files.
+   Strictly for Reference Implementation */
+/* Vendor Specific code - IMG begins */
+/*! 
+ *  OMX_IMG_ASPECTRATIOTYPE
+ *  Can be used with OMX_IndexImgAspectRatio
+ */
+typedef struct _OMX_IMG_ASPECTRATIOTYPE {
+	OMX_U32 nSize;              
+	OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex; 
+    OMX_U32 nNumerator;					
+    OMX_U32 nDenominator;				
+} OMX_IMG_ASPECTRATIOTYPE;
+
+/*!
+ *  OMX_IMG_MULTIVIEWTYPE
+ */
+typedef struct _OMX_IMG_MULTIVIEWTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nViewID;
+} OMX_IMG_MULTIVIEWTYPE;
+
+/*!
+ ******************************************************************************
+
+ Used with 'OMX.img.index.enableMultiViewDecoding'.
+ The corresponding IMG index is OMX_IndexImgEnableMultiViewDecoding
+
+ *****************************************************************************/
+
+typedef struct EnableAndroidMultiViewDecoding {
+   OMX_U32 nSize;
+   OMX_VERSIONTYPE nVersion;
+   OMX_U32 nPortIndex;
+   OMX_BOOL enable;
+}OMX_EXT_PARAM_ENABLEMULTIVIEWDECODINGTYPE;
+/* Vendor Specific Code - IMG ends */
 
 #ifdef __cplusplus
 }
diff --git a/omx/openmax/OMX_VideoExt.h b/omx/openmax/OMX_VideoExt.h
deleted file mode 100644
index 63249e4..0000000
--- a/omx/openmax/OMX_VideoExt.h
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_VideoExt.h - OpenMax IL version 1.1.2
- * The OMX_VideoExt header file contains extensions to the
- * definitions used by both the application and the component to
- * access video items.
- */
-
-#ifndef OMX_VideoExt_h
-#define OMX_VideoExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Core.h>
-
-/** NALU Formats */
-typedef enum OMX_NALUFORMATSTYPE {
-    OMX_NaluFormatStartCodes = 1,
-    OMX_NaluFormatOneNaluPerBuffer = 2,
-    OMX_NaluFormatOneByteInterleaveLength = 4,
-    OMX_NaluFormatTwoByteInterleaveLength = 8,
-    OMX_NaluFormatFourByteInterleaveLength = 16,
-    OMX_NaluFormatCodingMax = 0x7FFFFFFF
-} OMX_NALUFORMATSTYPE;
-
-
-/** NAL Stream Format */
-typedef struct OMX_NALSTREAMFORMATTYPE{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_NALUFORMATSTYPE eNaluFormat;
-} OMX_NALSTREAMFORMATTYPE;
-
-/* Following Interlace related structures are added by IMG as part of 
-   passing Interlace related information to IL Client on Sequence and
-   frame basis. Only those structures/fields used by IMG are copied 
-   below from OpenMAX 1.2 header files.
-   Strictly for Reference Implementation */
-/* Vendor Specific code - IMG begins */
-
-/* Below Macros have detailed description in OMX 1.2 specification */
-/*!< Progressive frame */
-#define OMX_InterlaceFrameProgressive                   0x00000001 
-/*!< Decoded unit is a Paired interleaved frame with Top Field First- temporally ahead*/
-#define OMX_InterlaceInterleaveFrameTopFieldFirst       0x00000002
-/*!< Decoded unit is a Paired interleaved frame with Bottom Field First- temporally ahead*/
-#define OMX_InterlaceInterleaveFrameBottomFieldFirst    0x00000004
-/*!< Decoded unit is a Paired frame with all top fields and then bottom fields with Top Field First- temporally ahead*/
-#define OMX_InterlaceFrameTopFieldFirst                 0x00000008
-/*!< Decoded unit is a Paired frame with all top fields and then bottom fields with Bottom Field First- temporally ahead*/
-#define OMX_InterlaceFrameBottomFieldFirst              0x00000010
-/*!< Decoded unit contains only samples from Top field in every alternate line.Bottom field lines are don't care*/
-#define OMX_InterlaceInterleaveFieldTop                 0x00000020
-/*!< Decoded unit contains only samples from Bottom field in every alternate line.Top field lines are don't care*/
-#define OMX_InterlaceInterleaveFieldBottom              0x00000040
-
-/** 
- * Interlace Format types. 
- *
- * STRUCT MEMBERS:
- *  nSize               : Size of the structure in bytes
- *  nVersion            : OMX specification version information
- *  nPortIndex          : Port that this structure applies to
- *  nFormat             : The Interlace format contained in the Buffer.
- *  nTimeStamp          : The timestamp of the temporally second field.			
- */
-typedef struct OMX_INTERLACEFORMATTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex; 
-    OMX_U32 nFormat;
-    OMX_TICKS nTimeStamp;
-#ifdef OMX_ADDITIONAL_INTERLACE_INFO
-    OMX_U32 nRepeatFirstField;         // IMG Vendor Specific.
-	OMX_BOOL bMbaffFrameFlag;
-#endif
-} OMX_INTERLACEFORMATTYPE;
-
-/** 
- * Stream Interlace Format type. 
- *
- * STRUCT MEMBERS:
- *  nSize               : Size of the structure in bytes
- *  nVersion            : OMX specification version information
- *  nPortIndex          : Port that this structure applies to
- *  bInterlaceFormat    : If the stream is interlace or progressive
- *  nInterlaceFormats   : Different Interlace formats decoder has detected so far for the stream.
- */
-typedef struct  OMX_STREAMINTERLACEFORMATTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bInterlaceFormat;
-    OMX_U32 nInterlaceFormats;
-} OMX_STREAMINTERLACEFORMAT;
-
-/*! 
- *  OMX_IMG_ASPECTRATIOTYPE
- *  Can be used with OMX_IndexImgAspectRatio
- */
-typedef struct _OMX_IMG_ASPECTRATIOTYPE {
-	OMX_U32 nSize;              
-	OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex; 
-    OMX_U32 nNumerator;					
-    OMX_U32 nDenominator;				
-} OMX_IMG_ASPECTRATIOTYPE;
-
-/*!
- *  OMX_IMG_MULTIVIEWTYPE
- */
-typedef struct _OMX_IMG_MULTIVIEWTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nViewID;
-} OMX_IMG_MULTIVIEWTYPE;
-
-typedef enum OMX_VIDEO_VC1PROFILETYPE {
-    OMX_VIDEO_VC1ProfileUnused = 0,
-    OMX_VIDEO_VC1ProfileSimple,
-    OMX_VIDEO_VC1ProfileMain,
-    OMX_VIDEO_VC1ProfileAdvanced,
-    OMX_VIDEO_VC1ProfileUnknown           = 0x6EFFFFFF,
-    OMX_VIDEO_VC1ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    OMX_VIDEO_VC1ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_VC1ProfileMax
-} OMX_VIDEO_VC1PROFILETYPE;
-
-typedef enum OMX_VIDEO_VC1LEVELTYPE {
-    OMX_VIDEO_VC1LevelUnused = 0,
-    OMX_VIDEO_VC1LevelLow,
-    OMX_VIDEO_VC1LevelMedium,
-    OMX_VIDEO_VC1LevelHigh,
-    OMX_VIDEO_VC1Level0,
-    OMX_VIDEO_VC1Level1,
-    OMX_VIDEO_VC1Level2,
-    OMX_VIDEO_VC1Level3,
-    OMX_VIDEO_VC1Level4,
-    OMX_VIDEO_VC1LevelUnknown           = 0x6EFFFFFF,
-    OMX_VIDEO_VC1LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    OMX_VIDEO_VC1LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_VC1LevelMax
-} OMX_VIDEO_VC1LEVELTYPE;
-
-typedef struct OMX_VIDEO_PARAM_VC1TYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_VC1PROFILETYPE eProfile;
-    OMX_VIDEO_VC1LEVELTYPE eLevel;
-} OMX_VIDEO_PARAM_VC1TYPE;
-
-
-/*!
- ******************************************************************************
-
- Used with 'OMX.img.index.enableMultiViewDecoding'.
- The corresponding IMG index is OMX_IndexImgEnableMultiViewDecoding
-
- *****************************************************************************/
-
-typedef struct EnableAndroidMultiViewDecoding {
-   OMX_U32 nSize;
-   OMX_VERSIONTYPE nVersion;
-   OMX_U32 nPortIndex;
-   OMX_BOOL enable;
-}OMX_EXT_PARAM_ENABLEMULTIVIEWDECODINGTYPE;
-/* Vendor Specific Code - IMG ends */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_VideoExt_h */
-/* File EOF */
-- 
1.9.1

